

 

# 第31天

 

 

 

## [分发饼干](https://leetcode.cn/problems/assign-cookies/description/)

 

 

 

![image-20230310213942450](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310213942450.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=455 lang=cpp

 

*

 

* [455] 分发饼干

 

*

 

* https://leetcode.cn/problems/assign-cookies/description/

 

*

 

* algorithms

 

* Easy (56.79%)

 

 * Likes:    648

 

* Dislikes: 0

 

 * Total Accepted:    287K

 

* Total Submissions: 505.6K

 

 * Testcase Example:  '[1,2,3]\n[1,1]'

 

*

 

* 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

 

*

 

* 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >=

 

* g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 

*

 

*

 

* 示例 1:

 

*

 

*

 

* 输入: g = [1,2,3], s = [1,1]

 

* 输出: 1

 

* 解释:

 

* 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。

 

* 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。

 

* 所以你应该输出1。

 

*

 

*

 

* 示例 2:

 

*

 

*

 

* 输入: g = [1,2], s = [1,2,3]

 

* 输出: 2

 

* 解释:

 

* 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。

 

* 你拥有的饼干数量和尺寸都足以让所有孩子满足。

 

* 所以你应该输出2.

 

*

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1

 

* 0

 

* 1

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <iostream>

 

using namespace std;

 

#include <vector>

 

#include <algorithm>

 

class Solution {

 

public:

 

    int findContentChildren(vector<int>& g, vector<int>& s) {

 

        int result=0;

 

        sort(g.begin(),g.end());

 

        sort(s.begin(),s.end());

 

        int n = s.size()-1;

 

        int m = g.size() - 1;

 

        while (n >= 0 && m >= 0)

 

        {

 

            if (s[n] >= g[m])

 

            {

 

                n--;

 

                m--;

 

                result++;

 

            }else

 

            {

 

                m--;

 

            }

 

 

 

 

 

        }

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

## [摆动序列](https://leetcode.cn/problems/wiggle-subsequence/description/)

 

 

 

![image-20230310214009030](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214009030.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=376 lang=cpp

 

*

 

* [376] 摆动序列

 

*

 

* https://leetcode.cn/problems/wiggle-subsequence/description/

 

*

 

* algorithms

 

* Medium (47.19%)

 

 * Likes:    851

 

* Dislikes: 0

 

 * Total Accepted:    161.2K

 

* Total Submissions: 341.6K

 

 * Testcase Example:  '[1,7,4,9,2,5]'

 

*

 

* 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列

 

* 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

 

*

 

*

 

*

 

* 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

 

*

 

* 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5]

 

* 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

 

*

 

*

 

* 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

 

*

 

* 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：nums = [1,7,4,9,2,5]

 

* 输出：6

 

* 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

 

*

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：nums = [1,17,5,10,13,15,10,5,16,8]

 

* 输出：7

 

* 解释：这个序列包含几个长度为 7 摆动序列。

 

* 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

 

*

 

*

 

* 示例 3：

 

*

 

*

 

* 输入：nums = [1,2,3,4,5,6,7,8,9]

 

* 输出：2

 

*

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1

 

* 0

 

*

 

*

 

*

 

*

 

* 进阶：你能否用 O(n) 时间复杂度完成此题?

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    int wiggleMaxLength(vector<int>& nums) {

 

        if ( nums.size() <= 1)

 

        {

 

            return nums.size();

 

        }

 

 

 

        int curdiff = 0;

 

        int prediff = 0;

 

        int result = 1;

 

        for (int i = 1; i < nums.size(); i++)

 

        {

 

            curdiff = nums[i] - nums[i-1];

 

            if (curdiff > 0 && prediff <= 0 || curdiff < 0 && prediff >= 0)

 

            {

 

                result++;

 

                prediff = curdiff;

 

            }

 

 

 

        }

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

 

 

 

![image-20230310214023468](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214023468.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=53 lang=cpp

 

*

 

* [53] 最大子数组和

 

*

 

* https://leetcode.cn/problems/maximum-subarray/description/

 

*

 

* algorithms

 

* Medium (54.87%)

 

 * Likes:    5725

 

* Dislikes: 0

 

 * Total Accepted:    1.3M

 

* Total Submissions: 2.4M

 

 * Testcase Example:  '[-2,1,-3,4,-1,2,1,-5,4]'

 

*

 

* 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

*

 

* 子数组 是数组中的一个连续部分。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]

 

* 输出：6

 

* 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

 

*

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：nums = [1]

 

* 输出：1

 

*

 

*

 

* 示例 3：

 

*

 

*

 

* 输入：nums = [5,4,-1,7,8]

 

* 输出：23

 

*

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1 <= nums.length <= 10^5

 

* -10^4 <= nums[i] <= 10^4

 

*

 

*

 

*

 

*

 

* 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

using namespace std;

 

 

 

 

 

class Solution {

 

public:

 

    int maxSubArray(vector<int>& nums) {

 

        int sum = 0;

 

        int result = INT32_MIN;

 

        for (int i = 0; i < nums.size(); i++)

 

        {

 

            sum += nums[i];

 

            if (sum > result)

 

            {

 

                result = sum;

 

            }

 

 

 

            if (sum <= 0)

 

            {

 

                sum = 0;

 

            }

 

 

 

        }

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

# 第32天

 

 

 

## [买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

 

 

 

![image-20230310214045008](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214045008.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=122 lang=cpp

 

*

 

* [122] 买卖股票的最佳时机 II

 

*

 

* https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/

 

*

 

* algorithms

 

* Medium (71.52%)

 

 * Likes:    1986

 

* Dislikes: 0

 

 * Total Accepted:    801.7K

 

* Total Submissions: 1.1M

 

 * Testcase Example:  '[7,1,5,3,6,4]'

 

*

 

* 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

 

*

 

* 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

 

*

 

* 返回 你能获得的 最大 利润 。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：prices = [7,1,5,3,6,4]

 

* 输出：7

 

* 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4

 

* 。

 

* 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。

 

 * ⁠    总利润为 4 + 3 = 7 。

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：prices = [1,2,3,4,5]

 

* 输出：4

 

* 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4

 

* 。

 

* 总利润为 4 。

 

*

 

* 示例 3：

 

*

 

*

 

* 输入：prices = [7,6,4,3,1]

 

* 输出：0

 

* 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1 <= prices.length <= 3 * 10^4

 

* 0 <= prices[i] <= 10^4

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    int maxProfit(vector<int>& prices) {

 

        int result = 0;

 

        for (int i = 1; i < prices.size(); i++)

 

        {

 

            int profit = prices[i] - prices[i-1];

 

            if (profit > 0)

 

            {

 

                result += profit;

 

            }

 

 

 

        }

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)

 

 

 

![image-20230310214106488](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214106488.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=121 lang=cpp

 

*

 

* [121] 买卖股票的最佳时机

 

*

 

* https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/

 

*

 

* algorithms

 

* Easy (57.96%)

 

 * Likes:    2804

 

* Dislikes: 0

 

 * Total Accepted:    1M

 

* Total Submissions: 1.8M

 

 * Testcase Example:  '[7,1,5,3,6,4]'

 

*

 

* 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

 

*

 

* 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

 

*

 

* 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：[7,1,5,3,6,4]

 

* 输出：5

 

* 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。

 

 * ⁠    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

 

*

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：prices = [7,6,4,3,1]

 

* 输出：0

 

* 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

 

*

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1

 

* 0

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    int maxProfit(vector<int>& prices) {

 

        int result = INT32_MIN;

 

        int price_min = prices[0];

 

        for (int i = 1; i < prices.size(); i++)

 

        {

 

            if (price_min > prices[i])

 

            {

 

                price_min = prices[i];

 

            }

 

            if (result < prices[i] - price_min)

 

            {

 

                result = prices[i] - price_min;

 

            }

 

 

 

        }

 

 

 

        return result = result == INT32_MIN ? 0: result ;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

 

 

 

![image-20230310214121946](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214121946.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=55 lang=cpp

 

*

 

* [55] 跳跃游戏

 

*

 

* https://leetcode.cn/problems/jump-game/description/

 

*

 

* algorithms

 

* Medium (43.72%)

 

 * Likes:    2204

 

* Dislikes: 0

 

 * Total Accepted:    654.1K

 

* Total Submissions: 1.5M

 

 * Testcase Example:  '[2,3,1,1,4]'

 

*

 

* 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

 

*

 

* 数组中的每个元素代表你在该位置可以跳跃的最大长度。

 

*

 

* 判断你是否能够到达最后一个下标。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：nums = [2,3,1,1,4]

 

* 输出：true

 

* 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

 

*

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：nums = [3,2,1,0,4]

 

* 输出：false

 

* 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

 

*

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1

 

* 0

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    bool canJump(vector<int>& nums) {

 

        if (nums.size() == 1)

 

        {

 

            return 1;

 

        }

 

 

 

        int cover = 0;

 

        int i = 0;

 

        while (i <= cover)

 

        {

 

            int cover_tmp = i + nums[i];

 

            cover = max(cover,cover_tmp);

 

            i++;

 

            if (cover >= nums.size() - 1)

 

            {

 

                return true;

 

            }

 

 

 

        }

 

 

 

        return false;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/description/)

 

 

 

![image-20230310214138644](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214138644.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=45 lang=cpp

 

*

 

* [45] 跳跃游戏 II

 

*

 

* https://leetcode.cn/problems/jump-game-ii/description/

 

*

 

* algorithms

 

* Medium (45.22%)

 

 * Likes:    1966

 

* Dislikes: 0

 

 * Total Accepted:    449.5K

 

* Total Submissions: 993.9K

 

 * Testcase Example:  '[2,3,1,1,4]'

 

*

 

* 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

 

*

 

* 每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j]

 

* 处:

 

*

 

*

 

* 0 <= j <= nums[i] 

 

* i + j < n

 

*

 

*

 

* 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

 

*

 

*

 

*

 

* 示例 1:

 

*

 

*

 

* 输入: nums = [2,3,1,1,4]

 

* 输出: 2

 

* 解释: 跳到最后一个位置的最小跳跃数是 2。

 

* 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

 

*

 

*

 

* 示例 2:

 

*

 

*

 

* 输入: nums = [2,3,0,1,4]

 

* 输出: 2

 

*

 

*

 

*

 

*

 

* 提示:

 

*

 

*

 

* 1 <= nums.length <= 10^4

 

* 0 <= nums[i] <= 1000

 

* 题目保证可以到达 nums[n-1]

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

using namespace std;

 

 

 

 

 

class Solution {

 

public:

 

    int jump(vector<int>& nums) {

 

        int step = 0;

 

        int curdis = 0;

 

        int nextdis = 0;

 

        for (int i = 0; i < nums.size(); i++)

 

        {

 

            nextdis = max(i + nums[i] , nextdis);

 

            if (i == curdis)

 

            {

 

                if (curdis < nums.size() - 1)

 

                {

 

                    step++;

 

                  curdis =  nextdis;

 

                  if (nextdis > nums.size() -1)

 

                  {

 

                    break;

 

                  }

 

 

 

                }else

 

                {

 

                    break;

 

                }

 

 

 

 

 

 

 

            }

 

 

 

        }

 

        return step;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

# 第33天

 

 

 

## [K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)

 

 

 

![image-20230310214151946](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214151946.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=1005 lang=cpp

 

*

 

* [1005] K 次取反后最大化的数组和

 

*

 

* https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/

 

*

 

* algorithms

 

* Easy (51.19%)

 

 * Likes:    320

 

* Dislikes: 0

 

 * Total Accepted:    113.8K

 

* Total Submissions: 222.3K

 

 * Testcase Example:  '[4,2,3]\n1'

 

*

 

* 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：

 

*

 

*

 

* 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。

 

*

 

*

 

* 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。

 

*

 

* 以这种方式修改数组后，返回数组 可能的最大和 。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：nums = [4,2,3], k = 1

 

* 输出：5

 

* 解释：选择下标 1 ，nums 变为 [4,-2,3] 。

 

*

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：nums = [3,-1,0,2], k = 3

 

* 输出：6

 

* 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。

 

*

 

*

 

* 示例 3：

 

*

 

*

 

* 输入：nums = [2,-3,-1,5,-4], k = 2

 

* 输出：13

 

* 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。

 

*

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1 <= nums.length <= 10^4

 

* -100 <= nums[i] <= 100

 

* 1 <= k <= 10^4

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

 

 

 

 

class Solution {

 

public:

 

    int largestSumAfterKNegations(vector<int>& nums, int k) {

 

        sort(nums.begin(),nums.end());

 

        for (int i = 0; i < k; i++)

 

        {

 

            nums[0] = -nums[0];

 

            sort(nums.begin(),nums.end());

 

        }

 

        int sum = 0;

 

        for (int i = 0; i < nums.size(); i++)

 

        {

 

            sum+=nums[i];

 

        }

 

        return sum;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [加油站](https://leetcode.cn/problems/gas-station/description/)

 

 

 

![image-20230310214206905](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214206905.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=134 lang=cpp

 

*

 

* [134] 加油站

 

*

 

* https://leetcode.cn/problems/gas-station/description/

 

*

 

* algorithms

 

* Medium (52.30%)

 

 * Likes:    1149

 

* Dislikes: 0

 

 * Total Accepted:    229.5K

 

* Total Submissions: 439.1K

 

 * Testcase Example:  '[1,2,3,4,5]\n[3,4,5,1,2]'

 

*

 

* 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

 

*

 

* 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

 

*

 

* 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一

 

* 的。

 

*

 

*

 

*

 

* 示例 1:

 

*

 

*

 

* 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]

 

* 输出: 3

 

* 解释:

 

* 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油

 

* 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油

 

* 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油

 

* 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油

 

* 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油

 

* 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。

 

* 因此，3 可为起始索引。

 

*

 

* 示例 2:

 

*

 

*

 

* 输入: gas = [2,3,4], cost = [3,4,3]

 

* 输出: -1

 

* 解释:

 

* 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。

 

* 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油

 

* 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油

 

* 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油

 

* 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。

 

* 因此，无论怎样，你都不可能绕环路行驶一周。

 

*

 

*

 

*

 

* 提示:

 

*

 

*

 

* gas.length == n

 

* cost.length == n

 

* 1 <= n <= 10^5

 

* 0 <= gas[i], cost[i] <= 10^4

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {

 

        vector<int> dif(gas.size(),0);

 

        int total = 0;

 

        for (int i = 0; i < gas.size(); i++)

 

        {

 

            dif[i] = gas[i] - cost[i];

 

            total += dif[i];

 

        }

 

 

 

        if (total < 0)

 

        {

 

            return -1;

 

        }

 

 

 

        int  curdif = 0;

 

        int result = 0;

 

        for (int i = 0; i < gas.size(); i++)

 

        {

 

            curdif += dif[i];

 

            if (curdif < 0)

 

            {

 

                result = i + 1;

 

                curdif = 0;

 

            }

 

 

 

        }

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [分发糖果](https://leetcode.cn/problems/candy/description/)

 

 

 

![image-20230310214219734](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214219734.png)

 

 

 

```Cpp

 

/*

 

* @lc app=leetcode.cn id=135 lang=cpp

 

*

 

* [135] 分发糖果

 

*

 

* https://leetcode.cn/problems/candy/description/

 

*

 

* algorithms

 

* Hard (49.59%)

 

 * Likes:    1111

 

* Dislikes: 0

 

 * Total Accepted:    194.2K

 

* Total Submissions: 391.7K

 

 * Testcase Example:  '[1,0,2]'

 

*

 

* n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

 

*

 

* 你需要按照以下要求，给这些孩子分发糖果：

 

*

 

*

 

* 每个孩子至少分配到 1 个糖果。

 

* 相邻两个孩子评分更高的孩子会获得更多的糖果。

 

*

 

*

 

* 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：ratings = [1,0,2]

 

* 输出：5

 

* 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

 

*

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：ratings = [1,2,2]

 

* 输出：4

 

* 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。

 

 * ⁠    第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* n == ratings.length

 

* 1 <= n <= 2 * 10^4

 

* 0 <= ratings[i] <= 2 * 10^4

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    int candy(vector<int>& ratings) {

 

        if (ratings.size() == 1)

 

        {

 

            return 1;

 

        }

 

 

 

       vector<int> left(ratings.size(),1);

 

       vector<int> right(ratings.size(),1);

 

       for (int i = 1; i < ratings.size(); i++)

 

       {

 

        if (ratings[i] > ratings[i-1])

 

        {

 

            left[i] = left[i-1] + 1;

 

        }

 

       }

 

       for (int i = ratings.size()-2; i >= 0; i--)

 

       {

 

        if (ratings[i] > ratings[i+1])

 

        {

 

            right[i] = right[i+1] + 1;

 

        }

 

       }

 

       int result = 0;

 

        for (int i = 0; i < ratings.size(); i++){

 

            result += max(left[i],right[i]);

 

        }

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

# 第34天

 

 

 

## [柠檬水找零](https://leetcode.cn/problems/lemonade-change/description/)

 

 

 

![image-20230310214233512](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214233512.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=860 lang=cpp

 

*

 

* [860] 柠檬水找零

 

*

 

* https://leetcode.cn/problems/lemonade-change/description/

 

*

 

* algorithms

 

* Easy (58.57%)

 

 * Likes:    414

 

* Dislikes: 0

 

 * Total Accepted:    154.4K

 

* Total Submissions: 263.7K

 

 * Testcase Example:  '[5,5,5,10,20]'

 

*

 

* 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

 

*

 

* 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

 

*

 

* 注意，一开始你手头没有任何零钱。

 

*

 

* 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false

 

* 。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：bills = [5,5,5,10,20]

 

* 输出：true

 

* 解释：

 

* 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。

 

* 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。

 

* 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。

 

* 由于所有客户都得到了正确的找零，所以我们输出 true。

 

*

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：bills = [5,5,10,10,20]

 

* 输出：false

 

* 解释：

 

* 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。

 

* 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。

 

* 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。

 

* 由于不是每位顾客都得到了正确的找零，所以答案是 false。

 

*

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1 <= bills.length <= 10^5

 

* bills[i] 不是 5 就是 10 或是 20 

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

class Solution {

 

public:

 

    bool lemonadeChange(vector<int>& bills) {

 

        int five = 0,ten = 0,twety = 0;

 

        for(int value : bills){

 

            if (value == 5)

 

            {

 

                five++;

 

            }else if(value == 10){

 

                ten++;

 

 

 

                if (five == 0)

 

                {

 

                    return false;

 

                }

 

                five--;

 

            }else

 

            {

 

                twety++;

 

                if (ten >= 1 && five >= 1)

 

                {

 

                    ten--;

 

                    five--;

 

                }else if (five >= 3)

 

                {

 

                    five -=3;

 

                }else{

 

                    return false;

 

                }

 

 

 

 

 

            }

 

 

 

 

 

        }

 

        return true;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

 

 

 

![image-20230310214247358](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214247358.png)

 

 

 

```cpp

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

 

 

    //cmp function

 

    static bool cmp(const vector<int>& a,const vector<int>& b){

 

        if (a[0] == b[0])

 

        {

 

            return a[1] < b[1];

 

        }

 

        return a[0] > b[0];

 

    }

 

 

 

    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {

 

        vector<vector<int>> result;

 

 

 

        sort(people.begin(),people.end(),cmp);

 

        for (int i = 0; i < people.size(); i++)

 

        {

 

            int position = people[i][1];

 

            result.insert(result.begin() + position,people[i]);

 

        }

 

        return result;

 

    }

 

};

 

```

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

## [用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/)

 

 

 

![image-20230310214258953](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214258953.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=452 lang=cpp

 

*

 

* [452] 用最少数量的箭引爆气球

 

*

 

* https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/

 

*

 

* algorithms

 

* Medium (50.80%)

 

 * Likes:    731

 

* Dislikes: 0

 

 * Total Accepted:    183.8K

 

* Total Submissions: 362K

 

 * Testcase Example:  '[[10,16],[2,8],[1,6],[7,12]]'

 

*

 

* 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend]

 

* 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

 

*

 

* 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足

 

* xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

 

*

 

* 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：points = [[10,16],[2,8],[1,6],[7,12]]

 

* 输出：2

 

* 解释：气球可以用2支箭来爆破:

 

* -在x = 6处射出箭，击破气球[2,8]和[1,6]。

 

* -在x = 11处发射箭，击破气球[10,16]和[7,12]。

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：points = [[1,2],[3,4],[5,6],[7,8]]

 

* 输出：4

 

* 解释：每个气球需要射出一支箭，总共需要4支箭。

 

*

 

* 示例 3：

 

*

 

*

 

* 输入：points = [[1,2],[2,3],[3,4],[4,5]]

 

* 输出：2

 

* 解释：气球可以用2支箭来爆破:

 

* - 在x = 2处发射箭，击破气球[1,2]和[2,3]。

 

* - 在x = 4处射出箭，击破气球[3,4]和[4,5]。

 

*

 

*

 

*

 

*

 

*

 

* 提示:

 

*

 

*

 

* 1 <= points.length <= 10^5

 

* points[i].length == 2

 

* -2^31 <= xstart < xend <= 2^31 - 1

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    static bool cmp(vector<int> &a,vector<int> &b){

 

        return a[0] < b[0];

 

    }

 

    int findMinArrowShots(vector<vector<int>>& points) {

 

        sort(points.begin(),points.end(),cmp);

 

        int result = 1;

 

        for (int i = 1; i < points.size(); i++)

 

        {

 

            if (points[i][0] > points[i-1][1])

 

            {

 

                result++;

 

            }else {

 

                points[i][1] = min(points[i][1],points[i-1][1]);

 

            }

 

 

 

        }

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

# 第35天

 

 

 

## [无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/description/)

 

 

 

![image-20230310214310286](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214310286.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=435 lang=cpp

 

*

 

* [435] 无重叠区间

 

*

 

* https://leetcode.cn/problems/non-overlapping-intervals/description/

 

*

 

* algorithms

 

* Medium (51.16%)

 

 * Likes:    890

 

* Dislikes: 0

 

 * Total Accepted:    198.8K

 

* Total Submissions: 388.6K

 

 * Testcase Example:  '[[1,2],[2,3],[3,4],[1,3]]'

 

*

 

* 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回

 

* 需要移除区间的最小数量，使剩余区间互不重叠 。

 

*

 

*

 

*

 

* 示例 1:

 

*

 

*

 

* 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]

 

* 输出: 1

 

* 解释: 移除 [1,3] 后，剩下的区间没有重叠。

 

*

 

*

 

* 示例 2:

 

*

 

*

 

* 输入: intervals = [ [1,2], [1,2], [1,2] ]

 

* 输出: 2

 

* 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

 

*

 

*

 

* 示例 3:

 

*

 

*

 

* 输入: intervals = [ [1,2], [2,3] ]

 

* 输出: 0

 

* 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

 

*

 

*

 

*

 

*

 

* 提示:

 

*

 

*

 

* 1 <= intervals.length <= 10^5

 

* intervals[i].length == 2

 

* -5 * 10^4 <= starti < endi <= 5 * 10^4

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

 

 

 

 

class Solution {

 

public:

 

 

 

    static bool cmp(vector<int> &a,vector<int> &b){

 

        return a[0] < b[0];

 

    }

 

    int eraseOverlapIntervals(vector<vector<int>>& intervals) {

 

        if (intervals.size() == 1)

 

        {

 

            return 0;

 

        }

 

 

 

        int result = 0;

 

        sort(intervals.begin(),intervals.end(),cmp);

 

        for (int i = 1; i < intervals.size(); i++)

 

        {

 

            if (intervals[i][0]  >= intervals[i-1][1])

 

            {

 

 

 

            }else{

 

                result++;

 

                intervals[i][1] = min(intervals[i-1][1],intervals[i][1]);

 

            }

 

 

 

        }

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [划分字母区间](https://leetcode.cn/problems/partition-labels/description/)

 

 

 

![image-20230310214325007](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214325007.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=763 lang=cpp

 

*

 

* [763] 划分字母区间

 

*

 

* https://leetcode.cn/problems/partition-labels/description/

 

*

 

* algorithms

 

* Medium (76.88%)

 

 * Likes:    897

 

* Dislikes: 0

 

 * Total Accepted:    150.4K

 

* Total Submissions: 195.6K

 

 * Testcase Example:  '"ababcbacadefegdehijhklij"'

 

*

 

* 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

 

*

 

* 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

 

*

 

* 返回一个表示每个字符串片段的长度的列表。

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：s = "ababcbacadefegdehijhklij"

 

* 输出：[9,7,8]

 

* 解释：

 

* 划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。

 

* 每个字母最多出现在一个片段中。

 

* 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：s = "eccbbbbdec"

 

* 输出：[10]

 

*

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1 <= s.length <= 500

 

* s 仅由小写英文字母组成

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    vector<int> partitionLabels(string s) {

 

        int rep [27] = {0};

 

        for (int i = 0; i < s.size(); i++)

 

        {

 

            rep[s[i] - 'a'] = i;

 

        }

 

        vector<int> result ;

 

        int left = 0;

 

        int right = 0;

 

        for (int i = 0; i < s.size(); i++)

 

        {

 

            right = max(right , rep[s[i] - 'a']);

 

            if (i == right)

 

            {

 

                result.push_back(right - left + 1);

 

                left = i + 1 ;

 

            }

 

 

 

        }

 

 

 

        return result;

 

 

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

## [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

 

 

 

![image-20230310214335739](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214335739.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=56 lang=cpp

 

*

 

* [56] 合并区间

 

*

 

* https://leetcode.cn/problems/merge-intervals/description/

 

*

 

* algorithms

 

* Medium (49.25%)

 

 * Likes:    1798

 

* Dislikes: 0

 

 * Total Accepted:    588.1K

 

* Total Submissions: 1.2M

 

 * Testcase Example:  '[[1,3],[2,6],[8,10],[15,18]]'

 

*

 

* 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]

 

* 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

 

*

 

*

 

*

 

* 示例 1：

 

*

 

*

 

* 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]

 

* 输出：[[1,6],[8,10],[15,18]]

 

* 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

 

*

 

*

 

* 示例 2：

 

*

 

*

 

* 输入：intervals = [[1,4],[4,5]]

 

* 输出：[[1,5]]

 

* 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

 

*

 

*

 

*

 

* 提示：

 

*

 

*

 

* 1 <= intervals.length <= 10^4

 

* intervals[i].length == 2

 

* 0 <= starti <= endi <= 10^4

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

class Solution {

 

public:

 

 

 

    static bool cmp(vector<int> &a,vector<int>&b){

 

        return a[0] < b[0];

 

    }

 

    vector<vector<int>> merge(vector<vector<int>>& intervals) {

 

        sort(intervals.begin(),intervals.end(),cmp);

 

        vector<int> path;

 

        vector<vector<int>> result;

 

        int i ;

 

        for ( i = 1; i < intervals.size(); i++)

 

        {

 

            if (intervals[i][0] <= intervals[i-1][1])

 

            {

 

                int end = max(intervals[i][1],intervals[i-1][1]);

 

                intervals[i] = {intervals[i-1][0],end};

 

            }else{

 

 

 

                result.push_back(intervals[i-1]);

 

            }

 

 

 

        }

 

        result.push_back(intervals[i-1]);

 

        return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

# 第37天

 

 

 

##  [单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/description/)

 

 

 

![image-20230310214348782](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214348782.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=738 lang=cpp

 

*

 

* [738] 单调递增的数字

 

*

 

* https://leetcode.cn/problems/monotone-increasing-digits/description/

 

*

 

* algorithms

 

* Medium (50.33%)

 

 * Likes:    337

 

* Dislikes: 0

 

 * Total Accepted:    80.7K

 

* Total Submissions: 160.4K

 

 * Testcase Example:  '10'

 

*

 

* 当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。

 

*

 

* 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。

 

*

 

*

 

*

 

* 示例 1:

 

*

 

*

 

* 输入: n = 10

 

* 输出: 9

 

*

 

*

 

* 示例 2:

 

*

 

*

 

* 输入: n = 1234

 

* 输出: 1234

 

*

 

*

 

* 示例 3:

 

*

 

*

 

* 输入: n = 332

 

* 输出: 299

 

*

 

*

 

*

 

*

 

* 提示:

 

*

 

*

 

* 0 <= n <= 10^9

 

*

 

*

 

*/

 

 

 

// @lc code=start

 

 

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

#include <string>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    int monotoneIncreasingDigits(int n) {

 

 

 

        string  strNum = to_string(n);

 

 

 

        int flag = strNum.size();

 

        for (int i = strNum.size() - 1; i > 0 ; i--)

 

        {

 

            if (strNum[i-1] >strNum[i])

 

            {

 

                flag = i;

 

                strNum[i-1]--;

 

            }

 

 

 

        }

 

 

 

        for (int i = flag; i < strNum.size(); i++)

 

        {

 

            strNum[i] = '9';

 

        }

 

 

 

        return stoi(strNum);

 

 

 

 

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

##  [买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

 

 

 

![image-20230310214403445](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214403445.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    int maxProfit(vector<int>& prices, int fee) {

 

        int result = 0;

 

        int minPrice = prices[0]; // 记录最低价格

 

        for (int i = 1; i < prices.size(); i++) {

 

            // 情况二：相当于买入

 

            if (prices[i] < minPrice) minPrice = prices[i];

 

 

 

            // 情况三：保持原有状态（因为此时买则不便宜，卖则亏本）

 

            if (prices[i] >= minPrice && prices[i] <= minPrice + fee) {

 

                continue;

 

            }

 

 

 

            // 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出

 

            if (prices[i] > minPrice + fee) {

 

                result += prices[i] - minPrice - fee;

 

                minPrice = prices[i] - fee; // 情况一，这一步很关键，避免重复扣手续费

 

            }

 

        }

 

        return result;

 

    }

 

};

 

 

 

```

 

 

 

 

 

# 第38天（动态规划）

 

## [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

 

 

 

![image-20230310214412471](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214412471.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    int fib(int n) {

 

        vector<int> dp(n+1,0);

 

        dp[0] = 0;

 

        if(n ==0){

 

            return dp[n];

 

        }

 

        dp[1] = 1;

 

        for(int i = 2;i <= n ; i++){

 

            dp[i] = dp[i-1] + dp[i-2];

 

        }

 

        int result = dp[n];

 

        return  result;

 

    }

 

};

 

```

 

 

 

## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

 

 

 

![image-20230310214425721](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214425721.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    int climbStairs(int n) {

 

        if(n <=2) return  n;

 

        vector<int> dp(n+1,0);

 

        int result;

 

        dp[1] = 1;

 

        dp[2] = 2;

 

        for(int i = 3; i <= n ; i++){

 

            dp[i] = dp[i-1] + dp[i-2];

 

        }

 

        result = dp[n];

 

        return result;

 

    }

 

};

 

```

 

 

 

## [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

 

 

 

![image-20230310214434835](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214434835.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    int minCostClimbingStairs(vector<int>& cost) {

 

        int result;

 

        int n = cost.size();

 

        vector<int> dp(n+1);//花费

 

        dp[0] = 0;

 

        dp[1] = 0;

 

        for(int i =2; i <= n ; i++){

 

            dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);

 

        }

 

        result = dp[n];

 

        return  result;

 

    }

 

};

 

```

 

 

 

 

 

 

 

# 第39天

 

 

 

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

 

 

 

![image-20230310214444719](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214444719.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    int uniquePaths(int m, int n) {

 

        vector<vector<int>> dp(m,vector<int>(n,0));

 

        dp[0][0] = 1;

 

        for(int i =1; i < m;i++){

 

            dp[i][0] = 1;

 

        }

 

        for(int i =1; i < n;i++){

 

            dp[0][i] = 1;

 

        }

 

        for(int i = 1; i < m; i++){

 

            for(int j = 1; j < n; j++){

 

                dp[i][j] =dp[i-1][j]+dp[i][j-1];

 

            }

 

        }

 

        return dp[m-1][n-1];

 

    }

 

};

 

```

 

 

 

## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

 

 

 

![image-20230310214452745](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214452745.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {

 

        int m = obstacleGrid.size();

 

        int n = obstacleGrid[0].size();

 

        vector<vector<int>> dp(m,vector<int>(n,0));

 

        // //chushihua

 

        // for(int i = 0; i < m; i++)

 

        // {

 

        //     dp[i][0] =1;

 

        // }

 

        // for(int i = 0; i < n; i++)

 

        // {

 

        //     dp[0][i] =1;

 

        // }

 

        //obs

 

        dp[0][0] = 1;

 

        if(obstacleGrid[0][0] == 1) return 0;

 

        for(int i = 0; i < m; i++){

 

            for(int j = 0; j < n; j++){

 

                if(obstacleGrid[i][j] == 1){

 

                    dp[i][j] = 0;

 

                }else{

 

                    if(i == 0 && j > 0){

 

                    dp[i][j] = dp[i][j-1];

 

                }

 

                    if(j == 0 && i > 0){

 

                        dp[i][j] = dp[i-1][j];

 

                    }

 

                    if(i > 0 && j >0){

 

                    dp[i][j] = dp[i-1][j] + dp[i][j-1];

 

                }

 

                }

 

            }

 

        }

 

        return dp[m-1][n-1];

 

    }

 

};

 

```

 

 

 

这个麻烦了 标准的方法

 

 

 

 

 

 

 

```cpp

 

class Solution {

 

public:

 

    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {

 

        int m = obstacleGrid.size();

 

        int n = obstacleGrid[0].size();

 

    if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0

 

            return 0;

 

        vector<vector<int>> dp(m, vector<int>(n, 0));

 

        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++)

 

        {

 

            dp[i][0] = 1;

 

        }

 

        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;

 

        for (int i = 1; i < m; i++) {

 

            for (int j = 1; j < n; j++) {

 

                if (obstacleGrid[i][j] == 1) continue;

 

                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

 

            }

 

        }

 

        return dp[m - 1][n - 1];

 

    }

 

};

 

```

 

 

 

 

 

 

 

 

 

 

 

# 第40天

 

 

 

## [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

 

 

 

![image-20230310214503417](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214503417.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    int integerBreak(int n) {

 

        vector<int> dp(n+1,0);

 

        dp[2] = 1;

 

        for(int i = 3; i <= n; i++){

 

            for(int j = 1; j < i; j++){

 

                int tmp = max((i-j)*j,dp[i-j]*j);

 

                dp[i] = max(dp[i],tmp);

 

            }

 

        }

 

        return dp[n];

 

    }

 

};

 

```

 

 

 

## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

 

 

 

![image-20230310214512302](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230310214512302.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    int numTrees(int n) {

 

        if(n <= 1) return 1;

 

        vector<int> dp(n+1,0);

 

        dp[0] = 1;

 

        dp[1] = 1;

 

        dp[2] = 2;

 

        for(int i = 3; i <= n; i++){

 

            for(int j = 1; j <= i;j++){

 

                dp[i]+= dp[j-1] * dp[i-j];

 

            }

 

        }

 

        return dp[n];

 

    }

 

};

 

```

 

 

 




