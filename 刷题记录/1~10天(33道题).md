

 

# **第1天**

 

 

 

**| 704. 二分查找、27. 移除元素**

 

 

 

## [704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/submissions/)

 

 

 

```c

 

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

 

 

 

 

 

示例 1:

 

 

 

输入: nums = [-1,0,3,5,9,12], target = 9

 

输出: 4

 

解释: 9 出现在 nums 中并且下标为 4

 

示例 2:

 

 

 

输入: nums = [-1,0,3,5,9,12], target = 2

 

输出: -1

 

解释: 2 不存在 nums 中因此返回 -1

 

```

 

 

 

 

 

 

 

```c++

 

class Solution {

 

public:

 

    int search(vector<int>& nums, int target) {

 

        int left = 0;

 

        int right = nums.size()-1;

 

        while(left <= right){

 

            int middle = (left+right)/2;

 

            if (nums[middle] < target ){

 

 

 

                left = middle +1;

 

            }

 

           else if (nums[middle] > target ){

 

 

 

                right = middle -1;

 

            }

 

            else{

 

                return middle;

 

            }

 

 

 

        }

 

        return -1;

 

    }

 

};

 

```

 

 

 

思路：找到对应区间很关键，要理解<=和<的对应代码以及它的含义！

 

 

 

 

 

 

 

## [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/submissions/)

 

 

 

```c

 

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

 

 

 

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

 

 

 

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

 

 

 

 

 

说明:

 

 

 

为什么返回数值是整数，但输出的答案是数组呢?

 

 

 

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

 

 

 

你可以想象内部操作如下:

 

 

 

// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝

 

int len = removeElement(nums, val);

 

 

 

// 在函数里修改输入数组对于调用者是可见的。

 

// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。

 

for (int i = 0; i < len; i++) {

 

    print(nums[i]);

 

}

 

 

 

 

 

示例 1：

 

 

 

输入：nums = [3,2,2,3], val = 3

 

输出：2, nums = [2,2]

 

解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

 

示例 2：

 

 

 

输入：nums = [0,1,2,2,3,0,4,2], val = 2

 

输出：5, nums = [0,1,4,0,3]

 

解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

 

 

 

```

 

 

 

 

 

 

 

```c++

 

class Solution {

 

public:

 

void my_swap(int &a,int &b){

 

   int tmp;

 

    tmp = a;

 

    a = b;

 

    b = tmp;

 

}

 

    int removeElement(vector<int>& nums, int val) {

 

        int low = 0;

 

        int fast = 0;

 

 

 

        int n = nums.size() - 1;

 

 

 

        while(fast <= n){

 

            if(nums[fast] == val){

 

                fast++;

 

            }

 

            else if(nums[fast] != val){

 

                my_swap(nums[fast],nums[low]);

 

                fast++;

 

                low++;

 

            }

 

        }

 

        return low;

 

    }

 

};

 

```

 

 

 

总结：双指针的应用，快的指针指向要处理的数组，慢的指针指向处理完成的数组，最后返回慢的指针即可

 

 

 

 

 

 

 

这两道题比较基础，没啥可说的

 

# 第2天

 

 

 

## [977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/submissions/)

 

 

 

```c

 

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

 

 

 

 

 

 

 

示例 1：

 

 

 

输入：nums = [-4,-1,0,3,10]

 

输出：[0,1,9,16,100]

 

解释：平方后，数组变为 [16,1,0,9,100]

 

排序后，数组变为 [0,1,9,16,100]

 

示例 2：

 

 

 

输入：nums = [-7,-3,2,3,11]

 

输出：[4,9,9,49,121]

 

 

 

 

 

提示：

 

 

 

1 <= nums.length <= 104

 

-104 <= nums[i] <= 104

 

nums 已按 非递减顺序 排序

 

 

 

 

 

```

 

 

 

 

 

 

 

```c++

 

class Solution {

 

public:

 

/*

 

    void    my_swap(int &a, int &b){

 

        int tmp ;

 

        tmp = a;

 

        a = b ;

 

        b = tmp;

 

    }

 

*/

 

    vector<int> sortedSquares(vector<int>& nums) {

 

        int slow = 0;

 

        int fast = nums.size()-1;

 

        vector<int> new_nums(fast+1,0);

 

        int finish = fast;

 

        while(slow <= fast){

 

            int tmp1 = nums[slow] * nums[slow];

 

            int tmp2 = nums[fast] * nums[fast];

 

            if (tmp1 < tmp2){

 

                new_nums[finish--] = tmp2;

 

                fast--;

 

            }

 

            else if(tmp2 <= tmp1){

 

                //my_swap(nums[fast],nums[slow]);

 

                new_nums[finish--] = tmp1;

 

 

 

                slow++;

 

            }

 

 

 

 

 

        }

 

        return new_nums;

 

    }

 

};

 

```

 

 

 

要新建一个存储结果的vector容器，然后利用双指针处理，当无法找到最小的时候，去找最大的放进去，然后返回新建的数组就可以了，正序不行可以搞倒叙！

 

 

 

 

 

 

 

第一遍没有想到新建容器，企图利用交换在一个数组中处理，来节约内存空间，但是交换之后会出现小的放在大的前面的情况，这点需要注意！！！！

 

 

 

 

 

 

 

## [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/)

 

 

 

```c

 

给定一个含有 n 个正整数的数组和一个正整数 target 。

 

 

 

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

 

 

 

 

 

 

示例 1：

 

 

 

输入：target = 7, nums = [2,3,1,2,4,3]

 

输出：2

 

解释：子数组 [4,3] 是该条件下的长度最小的子数组。

 

示例 2：

 

 

 

输入：target = 4, nums = [1,4,4]

 

输出：1

 

示例 3：

 

 

 

输入：target = 11, nums = [1,1,1,1,1,1,1,1]

 

输出：0

 

 

 

 

 

提示：

 

 

 

1 <= target <= 109

 

1 <= nums.length <= 105

 

1 <= nums[i] <= 105

 

 

 

 

 

```

 

 

 

 

 

 

 

```C++

 

class Solution {

 

public:

 

    int minSubArrayLen(int target, vector<int>& nums) {

 

        int len = INT_MAX;

 

        int sum = 0 ;

 

        int slow = 0;

 

        for(int i = 0; i < nums.size();i++){

 

            sum += nums[i];

 

            while(sum >= target){

 

                int len_tmp = i - slow + 1;

 

                len = len > len_tmp ? len_tmp : len;

 

                sum -= nums[slow++];

 

            }

 

 

 

        }

 

        return len==INT_MAX? 0:len;

 

    }

 

};

 

```

 

 

 

双指针的应用，要点是找到未处理的数组还有处理过的数组，两个指针分别指向它们，然后建立一个返回的长度即可，不要忘记没有大于的情况出现就好了

 

 

 

 

 

 

 

## [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

 

 

 

![image-20230307102842464](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307102842464.png)

 

 

 

```c

 

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

 

 

 

 

 

 

 

示例 1：

 

 

 

 

 

输入：n = 3

 

输出：[[1,2,3],[8,9,4],[7,6,5]]

 

示例 2：

 

 

 

输入：n = 1

 

输出：[[1]]

 

 

 

 

 

 

 

```

 

 

 

 

 

 

 

```cpp

 

#include<iostream>

 

using namespace std;

 

#include <vector>

 

 

 

class Solution {

 

public:

 

    vector<vector<int>> generateMatrix(int n) {

 

        vector<vector<int>> result(n,vector<int>(n,0));

 

        int loop = n / 2;

 

        int startx = 0, starty = 0;

 

        int mid = n / 2;

 

        int count = 1;

 

        int offset = 1;

 

        int i= 0  ,j = 0 ;

 

        while (loop--)

 

        {

 

            //从左到右

 

            for (i = startx; i < n - offset; i++)

 

            {

 

                result[starty][i] = count;

 

                count++;

 

            }

 

 

 

            //从上到下

 

            for ( j = starty; j < n - offset; j++)

 

            {

 

                result[j][i] = count;

 

                count++;

 

            }

 

 

 

            //从右到左

 

            for ( ; i > startx; i--)

 

            {

 

                result[j][i] = count;

 

                count++;

 

            }

 

 

 

            //从下到上

 

             for ( ; j > starty; j--)

 

            {

 

                result[j][i] = count;

 

                count++;

 

            }

 

            startx++;

 

            starty++;

 

            offset++;

 

        }

 

 

 

 

 

        if (n % 2)

 

        {

 

            result[mid][mid] =  n * n ;

 

        }

 

 

 

        return result;

 

    }

 

};

 

```

 

 

 

# 第3天

 

 

 

## [移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

 

```c

 

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

 

 

 

 

 

示例 1：

 

 

 

 

 

输入：head = [1,2,6,3,4,5,6], val = 6

 

输出：[1,2,3,4,5]

 

示例 2：

 

 

 

输入：head = [], val = 1

 

输出：[]

 

示例 3：

 

 

 

输入：head = [7,7,7,7], val = 7

 

输出：[]

 

 

 

 

 

```

 

 

 

![image-20230307102908207](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307102908207.png)

 

 

 

```c++

 

/**

 

* Definition for singly-linked list.

 

* struct ListNode {

 

 *     int val;

 

 *     ListNode *next;

 

 *     ListNode() : val(0), next(nullptr) {}

 

 *     ListNode(int x) : val(x), next(nullptr) {}

 

 *     ListNode(int x, ListNode *next) : val(x), next(next) {}

 

* };

 

*/

 

class Solution {

 

public:

 

    ListNode* removeElements(ListNode* head, int val) {

 

        ListNode *dummyhead = new ListNode();

 

        dummyhead->next = head;

 

        ListNode *cur = dummyhead;

 

        while (cur->next != nullptr)

 

        {

 

            if (cur->next->val == val)

 

            {

 

                cur->next = cur->next->next;

 

            }else{

 

                cur = cur->next;

 

            }

 

 

 

        }

 

 

 

        return dummyhead->next;

 

      // return head;

 

    }

 

};

 

```

 

 

 

就是正常的删除链表的基本操作，记得新建一个新的虚拟节点

 

 

 

 

 

 

 

## [设计链表](https://leetcode.cn/problems/design-linked-list/description/)

 

 

 

```c

 

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

 

 

 

在链表类中实现这些功能：

 

 

 

get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。

 

addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。

 

addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。

 

addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。

 

deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

 

 

 

 

 

示例：

 

 

 

MyLinkedList linkedList = new MyLinkedList();

 

linkedList.addAtHead(1);

 

linkedList.addAtTail(3);

 

linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3

 

linkedList.get(1);            //返回2

 

linkedList.deleteAtIndex(1);  //现在链表是1-> 3

 

linkedList.get(1);            //返回3

 

 

 

```

 

 

 

 

 

 

 

```c++

 

class MyLinkedList {

 

public:

 

    struct ListNode

 

    {

 

        int val;

 

        ListNode *next;

 

        ListNode(int x): val(x),next(nullptr){}

 

    };

 

 

 

    MyLinkedList() {

 

        dummyhead = new ListNode(0);

 

        size = 0;

 

    }

 

 

 

    int get(int index) {

 

        if (index < 0 || index >=size)

 

        {

 

            return -1;

 

        }

 

        ListNode *cur = dummyhead->next;

 

        while (index--)

 

        {

 

            cur = cur->next;

 

        }

 

        return cur->val;

 

    }

 

 

 

    void addAtHead(int val) {

 

        ListNode *node = new ListNode(val);

 

        node->next = dummyhead->next;

 

        dummyhead->next = node;

 

        size++;  

 

    }

 

 

 

    void addAtTail(int val) {

 

         ListNode *node = new ListNode(val);

 

         ListNode *cur = dummyhead;

 

         int size_tmp=  size;

 

         while (size_tmp--)

 

         {

 

            cur = cur->next;

 

         }

 

         cur->next = node;

 

         size++;

 

    }

 

 

 

    void addAtIndex(int index, int val) {

 

        if (index > size )

 

        {

 

            return;

 

        }

 

 

 

        ListNode *node = new ListNode(val);

 

        ListNode *cur = dummyhead;

 

        if (index < 0)

 

        {

 

            node->next = cur->next;

 

            cur->next = node;

 

            return ;

 

        }

 

 

 

        while (index--)

 

        {

 

            cur = cur->next;

 

        }

 

        node->next = cur->next;

 

        cur->next = node;

 

        size++;

 

    }

 

 

 

    void deleteAtIndex(int index) {

 

 

 

        if (index < 0 || index >= size)

 

        {

 

            return ;

 

        }

 

 

 

        ListNode *cur = dummyhead;

 

        while (index--)

 

        {

 

            cur = cur->next;

 

        }

 

        cur->next = cur->next->next;

 

        size--;

 

    }

 

 

 

private:

 

    int size;

 

    ListNode *dummyhead;

 

};

 

```

 

 

 

 

 

 

 

虚拟节点还有链表长度是很关键的点，加上后代码变得简洁很多

 

 

 

 

 

 

 

## [反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

 

 

 

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

 

 

![image-20230307103008886](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307103008886.png)

 

 

 

 

 

 

 

```c++

 

class Solution {

 

 

 

public:

 

    ListNode* reverseList(ListNode* head) {

 

        if (head == nullptr)

 

        {

 

            return head;

 

        }

 

 

 

        ListNode *pre = nullptr;

 

        ListNode *tmp ;

 

        ListNode *cur = head;

 

        while (cur->next != nullptr)

 

        {

 

            tmp = cur->next;

 

            cur->next = pre ;

 

            pre = cur;

 

            cur = tmp;

 

        }

 

        cur->next = pre;

 

        return cur;

 

    }

 

};

 

```

 

 

 

不要忘记空链表的情况，前面要加一个判断

 

# 第4天

 

 

 

## [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

 

 

 

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

 

 

![image-20230307103038052](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307103038052.png)

 

 

 

```cpp

 

#include<iostream>

 

using namespace std;

 

// struct ListNode

 

// {

 

//     int val;

 

//     ListNode *next;

 

//     ListNode(int val): val(0),next(nullptr){}

 

// };

 

 

 

class Solution {

 

public:

 

    ListNode* swapPairs(ListNode* head) {

 

        ListNode *dummyhead = new ListNode(0);

 

        dummyhead->next = head;

 

        ListNode *cur = dummyhead;

 

        while (cur->next !=nullptr && cur->next->next!=nullptr)

 

        {

 

            ListNode * tmp1, *tmp2;

 

            tmp1 = cur->next->next->next;

 

            tmp2 = cur->next;

 

            cur->next = cur->next->next;

 

            cur->next->next = tmp2;

 

            cur->next->next->next = tmp1;

 

 

 

            cur = cur->next->next;

 

        }

 

        return dummyhead->next;

 

    }

 

};

 

```

 

 

 

循环不变量，一直按照一个规则处理，一次移动两位即可

 

 

 

 

 

 

 

## [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

 

 

 

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

 

 

![image-20230307103056923](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307103056923.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    ListNode* removeNthFromEnd(ListNode* head, int n) {

 

        // if (head = nullptr)

 

        // {

 

 

 

        // }

 

 

 

        ListNode *dummyhead = new ListNode(0);

 

        dummyhead->next = head;

 

        ListNode *fast = dummyhead,*slow = dummyhead;

 

        while (n--)

 

        {

 

            fast = fast->next;

 

        }

 

        while (fast->next != nullptr)

 

        {

 

            fast = fast->next;

 

            slow = slow->next;

 

        }

 

        slow->next = slow->next->next;

 

        return dummyhead->next;

 

    }

 

};

 

```

 

 

 

双指针的链表应用，这个题目不需要判断链表为空的情况

 

 

 

 

 

 

 

## [面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

 

 

 

![image-20230307103135743](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307103135743.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

 

        ListNode * curA = headA;

 

        ListNode *curB = headB;

 

        int sizeA = 0, sizeB=0;

 

        int result;

 

        bool flag = 0;

 

        while(curA){

 

            curA = curA->next;

 

            sizeA++;

 

        }

 

        while(curB){

 

            curB = curB->next;

 

            sizeB++;

 

        }

 

        int dif = sizeA - sizeB;

 

        curA = headA;

 

        curB = headB;

 

        if(dif == 0){

 

            if(curA == curB){

 

                return curB;

 

            }

 

        }

 

        if(dif > 0){

 

            //sizea big

 

            while(dif--){

 

                 curA = curA->next;

 

            }

 

            flag = 1;

 

        }

 

        if(dif < 0){

 

            //sizea big

 

            if(flag == 1){

 

                dif++;

 

                flag = 0;

 

            }

 

            dif = -dif;

 

            while(dif--){

 

                 curB = curB->next;

 

            }

 

        }

 

 

 

 

 

        while(curA){

 

             if(curB == curA){

 

                return curA;

 

            }

 

            curA = curA->next;

 

            curB = curB->next;

 

 

 

        }

 

        return NULL;

 

    }

 

};

 

```

 

 

 

博主给的是用swap交换，这样可以大大简化运算，不需要额外的开销，比较方便。我这种方法由于判断条件过多，可能在某种情况下影响时间复杂度

 

 

 

## [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/submissions/)

 

 

 

![image-20230307103228502](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307103228502.png)

 

 

 

```cpp

 

/**

 

* Definition for singly-linked list.

 

* struct ListNode {

 

 *     int val;

 

 *     ListNode *next;

 

 *     ListNode(int x) : val(x), next(NULL) {}

 

* };

 

*/

 

class Solution {

 

public:

 

    ListNode *detectCycle(ListNode *head) {

 

        ListNode *fast = head;

 

        ListNode *slow = head;

 

        while(fast != NULL &&fast->next != NULL){

 

            fast = fast->next->next;

 

            slow = slow->next;

 

            if(fast == slow){

 

                ListNode *index1 = fast;

 

                ListNode *index2 = head;

 

                while(index1 != index2){

 

                    index1 = index1->next;

 

                    index2 = index2->next;

 

                }

 

                return index1;

 

            }

 

        }

 

        return NULL;

 

    }

 

};

 

```

 

 

 

注意逻辑，要在一个条件成立的情况下，来判断第二个循环是否相等

 

 

 

需要确定为什么第二个环进不去

 

 

 

 

 

 

 

# 第6天

 

 

 

## [有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/)

 

 

 

```

 

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

 

 

 

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 

 

 

 

 

 

 

示例 1:

 

 

 

输入: s = "anagram", t = "nagaram"

 

输出: true

 

示例 2:

 

 

 

输入: s = "rat", t = "car"

 

输出: false

 

 

 

```

 

 

 

 

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=242 lang=cpp

 

*

 

* [242] 有效的字母异位词

 

*/

 

 

 

// @lc code=start

 

#include <iostream>

 

#include<unordered_set>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    bool isAnagram(string s, string t) {

 

        int record[26] = {0};

 

        int n = s.size(),m = t.size();

 

        for (int i = 0; i < n; i++)

 

        {

 

            record[s[i] - 'a']++;

 

        }

 

 

 

        for (int j = 0; j < m; j++)

 

        {

 

            record[t[j] - 'a']--;

 

        }

 

 

 

        for (int k = 0; k < 26; k++)

 

        {

 

            if (record[k] != 0)

 

            {

 

                return false;

 

            }

 

 

 

        }

 

        return true;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

## [两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

 

 

 

```

 

给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

 

 

 

 

 

 

 

示例 1：

 

 

 

输入：nums1 = [1,2,2,1], nums2 = [2,2]

 

输出：[2]

 

示例 2：

 

 

 

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]

 

输出：[9,4]

 

解释：[4,9] 也是可通过的

 

 

 

```

 

 

 

 

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=349 lang=cpp

 

*

 

* [349] 两个数组的交集

 

*/

 

 

 

#include<vector>

 

#include<unordered_set>

 

using namespace std;

 

// @lc code=start

 

class Solution {

 

public:

 

    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {

 

 

 

    unordered_set<int> result_set;

 

    unordered_set<int> set(nums1.begin(),nums1.end());

 

 

 

    for(int num:nums2){

 

        if (set.find(num) != set.end())

 

        {

 

            result_set.insert(num);

 

        }

 

    }

 

    vector<int> result(result_set.begin(),result_set.end());

 

    return result;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

## [快乐数](https://leetcode.cn/problems/happy-number/description/)

 

 

 

```c

 

编写一个算法来判断一个数 n 是不是快乐数。

 

 

 

「快乐数」 定义为：

 

 

 

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。

 

然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。

 

如果这个过程 结果为 1，那么这个数就是快乐数。

 

如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

 

 

 

 

 

 

 

示例 1：

 

 

 

输入：n = 19

 

输出：true

 

解释：

 

12 + 92 = 82

 

82 + 22 = 68

 

62 + 82 = 100

 

12 + 02 + 02 = 1

 

示例 2：

 

 

 

输入：n = 2

 

输出：false

 

 

 

```

 

 

 

 

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=202 lang=cpp

 

*

 

* [202] 快乐数

 

*/

 

 

 

// @lc code=start

 

#include<vector>

 

#include<unordered_set>

 

using namespace std;

 

class Solution {

 

public:

 

int happy_num(int x){

        int num = 0;

        while (x)

        {

            int n = x % 10 ;

            num += n*n;

            x /= 10;

        }

        return num;

    }

 

 

bool isHappy(int n) {

    unordered_set<int> result;

    while(true){

        result.insert(n);

        n = happy_num(n);

        if (n == 1)

        {

            return true;

        }

        else if (result.find(n) != result.end())

        {

            break;

        }

    }

    return false;

}

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

## [两数之和](https://leetcode.cn/problems/two-sum/description/)

 

 

 

```

 

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

 

 

 

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

 

 

 

你可以按任意顺序返回答案。

 

 

 

 

 

 

 

示例 1：

 

 

 

输入：nums = [2,7,11,15], target = 9

 

输出：[0,1]

 

解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

 

示例 2：

 

 

 

输入：nums = [3,2,4], target = 6

 

输出：[1,2]

 

示例 3：

 

 

 

输入：nums = [3,3], target = 6

 

输出：[0,1]

 

 

 

 

 

```

 

 

 

 

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=1 lang=cpp

 

*

 

* [1] 两数之和

 

*/

 

 

 

// @lc code=start

 

#include<string.h>

 

#include<vector>

 

#include<algorithm>

 

#include<unordered_map>

 

using namespace std;

 

class Solution {

 

public:

 

    vector<int> twoSum(vector<int>& nums, int target) {

 

        unordered_map<int,int> map;

 

        for (int i = 0; i < nums.size(); i++)

 

        {

 

            auto iter = map.find(target - nums[i]);

 

            if (iter != map.end())

 

            {

 

                return {iter->second,i};

 

            }else{

 

                map.insert(pair<int,int>(nums[i],i));

 

            }

 

 

 

        }

 

        return {};

 

 

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

# 第7天

 

 

 

## [四数相加 II](https://leetcode.cn/problems/4sum-ii/description/)

 

 

 

![image-20230307104607566](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104607566.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=454 lang=cpp

 

*

 

* [454] 四数相加 II

 

*/

 

 

 

// @lc code=start

 

#include<string.h>

 

#include<vector>

 

#include<algorithm>

 

#include<unordered_map>

 

using namespace std;

 

class Solution {

 

public:

 

    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {

 

        unordered_map<int,int> map;

 

        for(int a:nums1){

 

            for(int b : nums2){

 

                map[a+b]++;

 

            }

 

        }

 

        int count = 0;

 

        for(int c:nums3){

 

            for(int d:nums4){

 

                int tmp = -(c+d); //a+b

 

                if (map.find(tmp) != map.end())

 

                {

 

                    count += map[tmp];

 

                }

 

 

 

 

 

            }

 

 

 

        }

 

        return count;

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

## [赎金信](https://leetcode.cn/problems/ransom-note/description/)

 

 

 

![image-20230307104623531](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230307104623531.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=383 lang=cpp

 

*

 

* [383] 赎金信

 

*/

 

 

 

 

 

// @lc code=start

 

#include<iostream>

 

#include<unordered_set>

 

using namespace std;

 

class Solution {

 

public:

 

    bool canConstruct(string ransomNote, string magazine) {

 

        int n = ransomNote.size();

 

        int m = magazine.size();

 

        if (n > m )

 

        {

 

            return false;

 

        }

 

 

 

        int record[26] = {0};

 

        for (int i = 0; i < m; i++)

 

        {

 

            record[magazine[i] - 'a']++;

 

        }

 

 

 

 

 

        for (int j = 0; j < n; j++)

 

        {

 

            record[ransomNote[j] - 'a']--;

 

        }

 

 

 

        for (int k = 0; k < 26; k++)

 

        {

 

            if (record[k] < 0)

 

            {

 

                return false;

 

            }

 

 

 

        }

 

        return true;

 

 

 

    }

 

};

 

// @lc code=end

 

 

 

 

 

```

 

 

 

 

 

 

 

## [三数之和](https://leetcode.cn/problems/3sum/description/)

 

 

 

![image-20230307104635325](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104635325.png)

 

 

 

```cpp

#include<iostream>

#include<vector>

#include<algorithm>

using namespace std;

class Solution {

public:

    vector<vector<int>> threeSum(vector<int>& nums) {

       vector<vector<int>> result;

       if (nums.size() == 0)

       {

        return result;

       }

       sort(nums.begin(),nums.end());

       for (int i = 0; i < nums.size(); i++)

       {

        if (i > 0 && nums[i] == nums[i-1])

        {

            continue;

        }

        int left = i + 1;

        int right = nums.size()-1;

        while (left < right)

        {

            int tmp = nums[i] + nums[left] + nums[right];

 

            if (tmp > 0)

            {

                right--;

            }else if (tmp < 0)

            {

                left++;

            }else

            {

                result.push_back(vector<int>{nums[i],nums[left],nums[right]});

                while (nums[right] == nums[right-1] && left <right)

                {

                    right--;

                }

                //不加限定条件000的情况过不去

                while (nums[left] == nums[left+1] && left < right)

                {

                    left++;

                }

                right--;

                left++;

 

            }

 

        }

 

       }

         return result;

    }

};

```

 

 

 

## [四数之和](https://leetcode.cn/problems/4sum/description/)

 

 

 

![image-20230307104645843](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104645843.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    vector<vector<int>> fourSum(vector<int>& nums, int target) {

 

        vector<vector<int>>  result;

 

        if (nums.size() == 0)

 

        {

 

            return result;

 

        }

 

        sort(nums.begin(),nums.end());

 

        for (int k = 0; k < nums.size(); k++)

 

        {

 

            if (k > 0 && nums[k] == nums[k-1])

 

            {

 

                continue;

 

            }

 

            for (int i = k+1; i < nums.size(); i++)

 

            {

 

                if (i > k+ 1&& nums[i] == nums[i-1])

 

                {

 

                    continue;

 

                }

 

 

 

                int left = i + 1;

 

                int right = nums.size()-1;

 

                while (left <right)

 

                {

 

                    if ((long)nums[k]+nums[i]+nums[left]+nums[right] > target)

 

                    {

 

                        right--;

 

                    }else if ((long)nums[k]+nums[i]+nums[left]+nums[right] < target)

 

                    {

 

                        left++;

 

                    }else{

 

                        result.push_back(vector<int>{nums[k],nums[i],nums[left],nums[right]});

 

                        while (left <right && nums[left] == nums[left+1])

 

                        {

 

                            left++;

 

                        }

 

                        while (left <right && nums[right] == nums[right-1])

 

                        {

 

                            right--;

 

                        }

 

                        left++;

 

                        right--;

 

 

 

                    }

 

 

 

                }

 

 

 

            }

 

 

 

        }

 

            return result;

 

    }

 

};

 

```

 

 

 

原始代码，剪枝操作的思路如下：

 

 

 

第一个k的剪枝

 

 

 

```cpp

 

if (k > nums.size()-4 || nums[k] > target && nums[k] >= 0) {

 

                break;

 

            }

 

```

 

 

 

先看长度，长度符合要求，看数值，排除负数情况后，看是否大于target，大于的话就可以剪枝了

 

 

 

第二个i的剪枝

 

 

 

```cpp

 

if (i > nums.size()-3||nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {

 

                    break;

 

                }

 

```

 

 

 

不剪枝也没啥，就是速度慢一点，核心是双指针的应用

 

 

 

# 第8天

 

 

 

## [344\. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/submissions/)

 

 

 

![image-20230307104708220](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104708220.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    void my_swap(char &a, char &b){

 

        char tmp;

 

        tmp = a;

 

        a= b;

 

        b = tmp;

 

    }

 

    void reverseString(vector<char>& s) {

 

        int left = 0;

 

        int right = s.size()-1;

 

        while(left < right){

 

            my_swap(s[left],s[right]);

 

            left++;

 

            right--;

 

        }

 

    }

 

};

 

```

 

## [反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/description/)

 

 

 

![image-20230307104720276](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104720276.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=541 lang=cpp

 

*

 

* [541] 反转字符串 II

 

*/

 

// @lc code=start

 

#include<iostream>

 

#include<string>

 

using namespace std;

 

class Solution {

 

public:

 

    string reverseStr(string s, int k) {

 

       int board = 0;

 

       while (board < s.size())

 

       {

 

        //第一种情况 size < k 全部翻转

 

        if (board+k > s.size())

 

        {

 

            reverse(s.begin() + board,s.end());

 

        }else

 

        {

 

            reverse(s.begin()+board,s.begin()+board+k);

 

        }

 

        board += 2*k;

 

       }

 

        return s;

 

    }

 

};

 

// @lc code=end

 

```

 

## [剑指 Offer 05. 替换空格 - 力扣（LeetCode）](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

 

 

 

![image-20230307104729679](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104729679.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    string replaceSpace(string s) {

 

        int len = 0;

 

        int m = s.size();

 

        for(int i = 0; i < s.size(); i++ ){

 

            if(s[i] == ' '){

 

                len++;

 

            }

 

        }

 

        len = s.size()+2*len;

 

        //s.resize(len);

 

        int j = 0,n = 0;

 

        string t(len,0);

 

        while(j <= s.size()){

 

            if(s[j] == ' '){

 

                t[n] = '%';

 

                t[n+1] = '2';

 

                t[n+2] = '0'; 

 

                j++;

 

                n+=3;

 

            }else{

 

                t[n] = s[j];

 

                n++;

 

                j++;

 

            }

 

        }

 

        return t;

 

    }

 

};

 

```

 

 

 

## [反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/ "https://leetcode.cn/problems/reverse-words-in-a-string/description/")

 

 

 

![image-20230307104744607](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104744607.png)

 

 

 

```cpp

class Solution {

public:

 

    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []

        for (int i = start, j = end; i < j; i++, j--) {

            swap(s[i], s[j]);

        }

    }

 

    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。

        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html

        for (int i = 0; i < s.size(); ++i) { //

            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。

                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。

                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。

                    s[slow++] = s[i++];

                }

            }

        }

        s.resize(slow); //slow的大小即为去除多余空格后的大小。

    }

 

    string reverseWords(string s) {

        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。

        reverse(s, 0, s.size() - 1);

        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。

        for (int i = 0; i <= s.size(); ++i) {

            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。

                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。

                start = i + 1; //更新下一个单词的开始下标start

            }

        }

        return s;

 

    }

};

```

 

 

 

## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

 

 

 

![image-20230307104756569](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104756569.png)

 

 

 

```cpp

class Solution {

public:

    string reverseLeftWords(string s, int n) {

        string tmp(n,'0');

        for(int i = 0; i < n; i++){

            tmp[i] = s[i];

        }

        int slow = 0;

        for(int i = n; i < s.size(); i++){

            s[slow++] = s[i];

        }

        int index = 0;

        for(int i = s.size() - n;i<s.size(); i++){

            s[i] = tmp[index++];

        }

        return s;

    }

};

```

 

 

 

# 第9天

 

## [找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

 

 

 

![image-20230307104808118](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104808118.png)

 

 

 

```cpp

class Solution {

public:

    void getNext(int* next, const string& s) {

        int j = -1;

        next[0] = j;

        for(int i = 1; i < s.size(); i++) { // 注意i从1开始

            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了

                j = next[j]; // 向前回退

            }

            if (s[i] == s[j + 1]) { // 找到相同的前后缀

                j++;

            }

            next[i] = j; // 将j（前缀的长度）赋给next[i]

        }

    }

    int strStr(string haystack, string needle) {

        if (needle.size() == 0) {

            return 0;

        }

        int next[needle.size()];

        getNext(next, needle);

        int j = -1; // // 因为next数组里记录的起始位置为-1

        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始

            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配

                j = next[j]; // j 寻找之前匹配的位置

            }

            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动

                j++; // i的增加在for循环里

            }

            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t

                return (i - needle.size() + 1);

            }

        }

        return -1;

    }

};

 

```

 

next数组的计算要看懂，第二次的字符匹配上从下标0开始的！！！

 

 

 

 

 

 

 

## [重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)

 

 

 

![image-20230307104819121](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104819121.png)

 

 

 

```cpp

class Solution {

public:

    void getNext (int* next, const string& s){

        next[0] = -1;

        int j = -1;

        for(int i = 1;i < s.size(); i++){

            while(j >= 0 && s[i] != s[j + 1]) {

                j = next[j];

            }

            if(s[i] == s[j + 1]) {

                j++;

            }

            next[i] = j;

        }

    }

    bool repeatedSubstringPattern (string s) {

        if (s.size() == 0) {

            return false;

        }

        int next[s.size()];

        getNext(next, s);

        int len = s.size();

        if (next[len - 1] != -1 && len % (len - (next[len - 1] + 1)) == 0) {

            return true;

        }

        return false;

    }

};

```

 

 

 

 

 

 

 

 

 

 

 

# 第10天

 

 

 

## [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

 

 

 

![image-20230307104830785](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104830785.png)

 

 

 

```cpp

#include<iostream>

#include <stack>

using namespace std;

 

class MyQueue {

public:

 

    stack<int> stIn;

    stack<int> stOut;

 

    MyQueue() {

 

    }

 

    void push(int x) {

        stIn.push(x);

    }

 

    int pop() {

        if (stOut.empty())

        {

            while (!stIn.empty())

            {

                stOut.push(stIn.top());

                stIn.pop();

            }

 

        }

        int result = stOut.top();

        stOut.pop();

        return result;

    }

 

    int peek() {

        if (stOut.empty())

        {

            while (!stIn.empty())

            {

                stOut.push(stIn.top());

                stIn.pop();

            }

        }

        int result = stOut.top();

 

        return result;

    }

 

    bool empty() {

        bool result = stIn.empty() && stOut.empty();

        return result;

    }

};

 

/**

* Your MyQueue object will be instantiated and called as such:

* MyQueue* obj = new MyQueue();

* obj->push(x);

* int param_2 = obj->pop();

* int param_3 = obj->peek();

* bool param_4 = obj->empty();

*/

```

 

 

 

了解模拟过程

 

 

 

![image](https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

 

 

 

 

 

## [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/description/)

 

![image-20230307104857343](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104857343.png)

 

 

 

```cpp

#include <deque>

#include <queue>

using namespace std;

 

class MyStack {

public:

 

    queue<int> que1;

    queue<int> que2;

    MyStack() {

 

    }

 

    void push(int x) {

        que1.push(x);

    }

 

    int pop() {

        int size = que1.size();

        while (size > 1)

        {

            que2.push(que1.front());

            que1.pop();

            size--;

        }

        int result = que1.front();

       // que1.pop();

        que1 = que2;

        while (!que2.empty())

        {

            que2.pop();

        }

 

        return result;

    }

 

    int top() {

        int result = que1.back();

        return result;

    }

 

    bool empty() {

        return que1.empty();

    }

};

 

/**

* Your MyStack object will be instantiated and called as such:

* MyStack* obj = new MyStack();

* obj->push(x);

* int param_2 = obj->pop();

* int param_3 = obj->top();

* bool param_4 = obj->empty();

*/

```

 

 

 

 

 

 

 

 

 

 

 

#

 

 

 

# 第一周拓展题

 

 

 

## [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

 

 

 

![image-20230307104920825](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104920825.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=34 lang=cpp

 

*

 

* [34] 在排序数组中查找元素的第一个和最后一个位置

 

*/

 

// @lc code=start

 

class Solution {

 

public:

 

    int searchleft(vector<int>& nums, int target){

 

        int left = 0, right = nums.size()-1;

 

        while (left <= right)

 

        {

 

            int mid = (left + right) /2 ;

 

            if (nums[mid] < target)

 

            {

 

                left = mid + 1;

 

            }

 

            else if (nums[mid] >= target)

 

            {

 

                right = mid - 1;

 

            }

 

        }

 

         return right;

 

    }

 

    int searchright(vector<int>& nums, int target){

 

        int left = 0, right = nums.size()-1;

 

        while (left <= right)

 

        {

 

            int mid = (left + right)/2;

 

            if (nums[mid] > target)

 

            {

 

                right = mid - 1;

 

            }

 

            else if (nums[mid] <= target)

 

            {

 

                left = mid + 1;

 

            }

 

        }

 

        return left;

 

    }

 

    vector<int> searchRange(vector<int>& nums, int target) {

 

        int leftboard = -1;

 

        int rightboard = -1;

 

        leftboard = searchleft(nums,target);

 

        rightboard = searchright(nums,target);

 

        if (rightboard - leftboard > 1)

 

        {

 

            return {leftboard+1,rightboard-1};

 

        }

 

        return {-1,-1};

 

    }

 

};

 

// @lc code=end

 

```

 

 

 

## [搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

 

 

 

![image-20230307104934012](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307104934012.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=35 lang=cpp

 

*

 

* [35] 搜索插入位置

 

*/

 

// @lc code=start

 

class Solution {

 

public:

 

    int searchInsert(vector<int>& nums, int target) {

 

        int left =0,right = nums.size()-1;

 

        while (left <= right)

 

        {

 

            int mid = (right - left)/2 +left;

 

            if (nums[mid] >= target)

 

            {

 

                right = mid - 1;

 

            }else if (nums[mid] < target)

 

            {

 

                left = mid + 1;

 

            }

 

        }

 

        return right+1;

 

    }

 

};

 

// @lc code=end

 

```

 

 

 

## [x 的平方根](https://leetcode.cn/problems/sqrtx/description/)

 

 

 

![image-20230307105001123](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307105001123.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=69 lang=cpp

 

*

 

* [69] x 的平方根

 

*/

 

// @lc code=start

 

class Solution {

 

public:

 

    int mySqrt(int x) {

 

        int left = 0,right = x;

 

        while (left <= right)

 

        {

 

            int mid = (left +right)/2;

 

            int tmp = mid * mid;

 

            if (tmp < x)

 

            {

 

                left  = mid + 1;

 

            }else if (tmp > x)

 

            {

 

                right = mid - 1;

 

            }else{

 

                return mid;

 

            }

 

        }

 

        return right;

 

    }

 

};

 

// @lc code=end

 

```

 

 

 

## [有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/description/)

 

 

 

![image-20230307105028214](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230307105028214.png)

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=367 lang=cpp

 

*

 

* [367] 有效的完全平方数

 

*/

 

// @lc code=start

 

class Solution {

 

public:

 

    bool isPerfectSquare(int num) {

 

        int left = 0, right = num;

 

        while (left <= right)

 

        {

 

            int mid = (left + right)/2;

 

            //数组越界的强制类型转换！

 

            double tmp = (double)mid * mid;

 

            if (tmp < num)

 

            {

 

                left = mid + 1;

 

            }else if (tmp > num)

 

            {

 

                right = mid - 1;

 

            }else {

 

                return true;

 

            }

 

        }

 

            return false;

 

    }

 

};

 

// @lc code=end

 

```

 

 

 




