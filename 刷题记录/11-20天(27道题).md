

 

# 第11天

 

## [有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)

 

 

 

![image-20230308205716170](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308205716170.png)

 

 

 

```cpp

 

#include <string>

 

#include <stack>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    bool isValid(string s) {

 

        stack<char> st;

 

        if (s.size() % 2 != 0)

 

        {

 

            return false;

 

        }

 

        for (int i = 0; i < s.size(); i++)

 

        {

 

            if (s[i] == '(')

 

            {

 

                st.push(')');

 

            }else if (s[i] == '{')

 

            {

 

                st.push('}');

 

            }else if (s[i] == '[')

 

            {

 

                 st.push(']');

 

            }else if (st.empty() || s[i] != st.top())

 

            {

 

                return false;

 

            }else

 

            {

 

                st.pop();

 

            }        

 

        }

 

        return st.empty();

 

 

 

    }

 

};

 

```

 

## [删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)

 

 

 

![image-20230308205841090](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308205841090.png)

 

 

 

```cpp

 

#include <string>

 

#include <stack>

 

#include <algorithm>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    string removeDuplicates(string s) {

 

        stack<char> st;

 

        for (int i = 0; i < s.size(); i++)

 

        {

 

            if (st.empty() || s[i] != st.top())

 

            {

 

                st.push(s[i]);

 

            }else

 

            {

 

                st.pop();

 

            }

 

        }

 

        string result = "";

 

        while (!st.empty())

 

        {

 

            result += st.top();

 

            st.pop();

 

        }

 

        reverse(result.begin(),result.end());

 

        return result;

 

    }

 

};

 

```

 

## [逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

 

 

 

![image-20230308205911916](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308205911916.png)

 

 

 

```cpp

 

#include <string>

 

#include <stack>

 

#include <vector>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

    int evalRPN(vector<string>& tokens) {

 

        stack<long long> st;

 

        for (int i = 0; i < tokens.size(); i++)

 

        {

 

            if (tokens[i] == "+"||tokens[i] == "-"||tokens[i] == "/"||tokens[i] == "*")

 

            {

 

                long long num1 = st.top();//second num

 

                st.pop();

 

                long long num2 = st.top();//first num

 

                st.pop();

 

                if (tokens[i] == "+")

 

                {

 

                    st.push(num1+num2);

 

                }else if (tokens[i] == "-")

 

                {

 

                    st.push(num2 -num1);

 

                }else if (tokens[i] == "*")

 

                {

 

                    st.push(num2*num1);

 

                }else if (tokens[i] == "/")

 

                {

 

                    st.push(num2/num1);

 

                }

 

            }else

 

            {

 

                st.push(stoll(tokens[i]));

 

            }

 

        }

 

        return st.top();

 

    }

 

};

 

```

 

栈用来做临近的字符或者数组的匹配上特别方便的，如果有类似的情况，可以第一时间想到利用栈来解决

 

 

 

 

 

 

 

# 第12天

 

## [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

 

 

 

![image-20230308205933801](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308205933801.png)

 

 

 

暴力解法：会超时

 

 

 

```cpp

 

/*

 

* @lc app=leetcode.cn id=239 lang=cpp

 

*

 

* [239] 滑动窗口最大值

 

*/

 

 

 

// @lc code=start

 

#include <string>

 

#include <stack>

 

#include <vector>

 

using namespace std;

 

 

 

class Solution {

 

    public:

 

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

 

    vector<int> result;

 

    for (int i = 0; i < nums.size()-k+1; i++)

 

    {

 

        int path = nums[i];

 

        for (int j = i+1; j < k+i; j++)

 

        {

 

            path =  path > nums[j] ? path : nums[j];

 

        }

 

            result.push_back(path);

 

    }

 

        return result;

 

        }

 

    };

 

// @lc code=end

 

 

 

 

 

```

 

队列的解法:

 

 

 

自己写一个单调队列，注意维护队列的单调性

 

 

 

```cpp

 

class Solution {

 

private:

 

    class MyQueue { //单调队列（从大到小）

 

    public:

 

        deque<int> que; // 使用deque来实现单调队列

 

        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。

 

        // 同时pop之前判断队列当前是否为空。

 

        void pop(int value) {

 

            if ( value == que.front()) {

 

                que.pop_front();

 

            }

 

        }

 

        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。

 

        // 这样就保持了队列里的数值是单调从大到小的了。

 

        void push(int value) {

 

            while (!que.empty() && value > que.back()) {

 

                que.pop_back();

 

            }

 

            que.push_back(value);

 

 

 

        }

 

        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。

 

        int front() {

 

            return que.front();

 

        }

 

    };

 

public:

 

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

 

        MyQueue que;

 

        vector<int> result;

 

        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列

 

            que.push(nums[i]);

 

        }

 

        result.push_back(que.front()); // result 记录前k的元素的最大值

 

        for (int i = k; i < nums.size(); i++) {

 

            que.pop(nums[i - k]); // 滑动窗口移除最前面元素

 

            que.push(nums[i]); // 滑动窗口前加入最后面的元素

 

            result.push_back(que.front()); // 记录对应的最大值

 

        }

 

        return result;

 

    }

 

};

 

```

 

## [前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/)

 

 

 

![image-20230308205950233](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308205950233.png)

 

需要掌握优先级队列，也就是大小顶堆的构造，链接如下：

 

[优先级队列学习](https://blog.csdn.net/qq_43964318/article/details/125879319/)

 

[B站讲解](https://www.bilibili.com/video/BV1P64y1h7dk/?spm_id_from=333.337.search-card.all.click&vd_source=14cddc7a29c69d2f2f52b0d3eb7cfe81)

 

```cpp

// 时间复杂度：O(nlogk)

// 空间复杂度：O(n)

class Solution {

public:

    // 小顶堆

    class mycomparison {

    public:

        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {

            return lhs.second > rhs.second;

        }

    };

    vector<int> topKFrequent(vector<int>& nums, int k) {

        // 要统计元素出现频率

        unordered_map<int, int> map; // map<nums[i],对应出现的次数>

        for (int i = 0; i < nums.size(); i++) {

            map[nums[i]]++;

        }

 

        // 对频率排序

        // 定义一个小顶堆，大小为k

        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

 

        // 用固定大小为k的小顶堆，扫面所有频率的数值

        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {

            pri_que.push(*it);

            if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k

                pri_que.pop();

            }

        }

 

        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组

        vector<int> result(k);

        for (int i = k - 1; i >= 0; i--) {

            result[i] = pri_que.top().first;

            pri_que.pop();

        }

        return result;

 

    }

};

```

 

核心思路如下：

 

 

 

1. 首先利用哈希表map映射，计算每个元素出现的次数

 

2. 构造优先级队列，使用小顶堆，要大的所以弹出小的

 

3. 利用小顶堆进行排序，大于要求的k个之后就弹出

 

4. 新建一个结果数组，讲堆顶元素插入，插入k个即可。要求顺序的话就从后面往前插入

 

 

 

其他解法：

 

```cpp

class Solution {

public:

    vector<int> topKFrequent(vector<int>& nums, int k) {

        unordered_map<int,int> map;

        vector<int> vec;

        vector<int> result;

        for(int i = 0; i < nums.size(); i++){

            map[nums[i]]++;

        }

        for(auto it = map.begin(); it != map.end(); it++){

            int tmp = it->second;

            vec.push_back(tmp);

        }

        sort(vec.begin(),vec.end());

      //  reverse(vec.begin(),vec.end());

 

        for(int i = 0; i < k;i++){

            int n = vec.size();    

            for(auto it = map.begin(); it != map.end(); it++){

                int tmp = it->second;

                if(tmp == vec[n-1]){

                    result.push_back(it->first);

                    map.erase(it->first);

                    vec.pop_back();

                    break;

                }

            }

        }

        return result;

    }

};

```

 

 

 

# 第13天

 

二叉树的遍历顺序

 

 

 

* 深度优先遍历

 

* 前序遍历（递归法，迭代法）

 

* 中序遍历（递归法，迭代法）

 

* 后序遍历（递归法，迭代法）

 

* 广度优先遍历

 

* 层次遍历（迭代法）

 

 

 

 

 

 

 

## [二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

 

 

 

![image-20230308210011259](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210011259.png)

 

 

 

```cpp

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

#include <vector>

 

#include <iostream>

 

using namespace std;

 

// struct TreeNode {

 

//       int val;

 

//       TreeNode *left;

 

//       TreeNode *right;

 

//       TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

//       TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

//   };

 

class Solution {

 

public:

 

    vector<int> result;

 

    void transation(TreeNode* root, vector<int> &vec){

 

        if (root == nullptr)

 

        {

 

            return ;

 

        }

 

 

 

        vec.push_back(root->val);

 

        transation(root->left,vec);

 

        transation(root->right,vec);

 

    }

 

    vector<int> preorderTraversal(TreeNode* root) {

 

        transation(root,result);

 

        return result;

 

    }

 

};

 

```

 

## [二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

 

 

 

![image-20230308210027703](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210027703.png)

 

 

 

```cpp

 

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

#include <vector>

 

#include <iostream>

 

using namespace std;

 

class Solution {

 

public:

 

    vector<int> result;

 

    void transation(TreeNode* root, vector<int> &vec){

 

        if (root == nullptr)

 

        {

 

            return ;

 

        }

 

 

 

 

 

        transation(root->left,vec);

 

        transation(root->right,vec);

 

        vec.push_back(root->val);

 

    }

 

 

 

    vector<int> postorderTraversal(TreeNode* root) {

 

        transation(root,result);

 

        return result;

 

    }

 

};

 

```

 

## [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

 

 

 

![image-20230308210039715](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210039715.png)

 

 

 

```cpp

 

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

 

 

//  struct TreeNode {

 

//      int val;

 

//      TreeNode *left;

 

//      TreeNode *right;

 

//      TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

//      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

//      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

//   };

 

 

 

 

 

#include<vector>

 

using namespace std;

 

 

 

class Solution {

 

public:

 

 

 

    void tracking(TreeNode* cur, vector<int> &result){

 

        if (cur == nullptr )

 

        {

 

            return ;

 

        }

 

        tracking(cur->left,result);

 

        result.push_back(cur->val);

 

        tracking(cur->right,result);

 

 

 

    }

 

 

 

    vector<int> inorderTraversal(TreeNode* root) {

 

        vector<int> result;

 

        tracking(root,result);

 

        return result;

 

 

 

    }

 

};

 

 

 

```

 

核心是改变递归的遍历顺序即可，比较基础

 

 

 

 

 

 

 

# 第14天

 

## [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

 

 

 

![image-20230308210603329](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210603329.png)

 

 

 

```cpp

 

class Solution {

 

public:

 

    vector<vector<int>> levelOrder(TreeNode* root) {

 

        queue<TreeNode*> que;

 

        if (root != NULL) que.push(root);

 

        vector<vector<int>> result;

 

        while (!que.empty()) {

 

            int size = que.size();

 

            vector<int> vec;

 

            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的

 

            for (int i = 0; i < size; i++) {

 

                TreeNode* node = que.front();

 

                que.pop();

 

                vec.push_back(node->val);

 

                if (node->left) que.push(node->left);

 

                if (node->right) que.push(node->right);

 

            }

 

            result.push_back(vec);

 

        }

 

        return result;

 

    }

 

};

 

```

 

递归法，寻找递归条件，然后每一层插入一个数组，相当于深度优先遍历然后插入，从而变成纵向遍历\~

 

 

 

层序遍历是广度优先搜索的一种，所以可以使用队列来迭代实现，而不是简单的递归

 

```cpp

class Solution {

public:

    vector<vector<int>> levelOrder(TreeNode* root) {

        queue<TreeNode*> que;

        if (root != NULL) que.push(root);

        vector<vector<int>> result;

        while (!que.empty()) {

            int size = que.size();

            vector<int> vec;

            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的

            for (int i = 0; i < size; i++) {

                TreeNode* node = que.front();

                que.pop();

                vec.push_back(node->val);

                if (node->left) que.push(node->left);

                if (node->right) que.push(node->right);

            }

            result.push_back(vec);

        }

        return result;

    }

};

```

 

 

 

 

 

##  [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

 

![image-20230311105118057](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230311105118057.png)

 

 

 

```cpp

class Solution {

public:

    vector<int> levelOrder(TreeNode* root) {

        vector<int> result;

        queue<TreeNode*> que;

        if(!root)  return result;

        que.push(root);

        while(!que.empty()){

            TreeNode * tmp = que.front();

            que.pop();

            result.push_back(tmp->val);

            if(tmp->left) que.push(tmp->left);

            if(tmp->right) que.push(tmp->right);

        }

        return result;

    }

};

```

 

 

 

 

 

 

 

## [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/)

 

 

 

![image-20230308210626983](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210626983.png)

 

 

 

```cpp

 

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

 

 

class Solution {

 

public:

 

    void backtracking(TreeNode* root){

 

        if (root == NULL) return ;

 

        swap(root->left, root->right);  // 中

 

        invertTree(root->left);         // 左

 

        invertTree(root->right);        // 右

 

 

 

    }

 

 

 

    TreeNode* invertTree(TreeNode* root) {

 

        backtracking(root);        

 

        return root;

 

    }

 

};

 

```

 

简单的翻转左右孩子！

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

## [对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

 

 

 

![image-20230308210720803](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210720803.png)

 

 

 

```cpp

 

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

 

 

#include <vector>

 

#include <iostream>

 

#include <algorithm>

 

using namespace std;

 

// struct TreeNode {

 

//       int val;

 

//       TreeNode *left;

 

//       TreeNode *right;

 

//       TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

//       TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

//   };

 

 

 

 

 

class Solution {

 

public:

 

    bool transation(TreeNode* left,TreeNode* right){

 

        if (left == NULL&& right == NULL)

 

        {

 

            return true;

 

        }else if (left != NULL&& right == NULL)

 

        {

 

            return false;

 

        }else if (left == NULL&& right!= NULL)

 

        {

 

            return false;

 

        }else if (left->val  != right->val)

 

        {

 

            return false;

 

        }

 

        bool out =  transation(left->left,right->right);

 

        bool in = transation(left->right,right->left);

 

        bool final = out && in;

 

        return final;

 

    }

 

 

 

 

 

    bool isSymmetric(TreeNode* root) {

 

        if (root == nullptr)

 

        {

 

            return true;

 

        }

 

 

 

        bool result = transation(root->left,root->right);

 

        return result;

 

    }

 

};

 

```

 

 

 

 

 

 

 

# 第16天

 

## [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

 

 

 

![image-20230308210733406](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210733406.png)

 

深度与高度的定义：

 

![image-20230311154334538](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230311154334538.png)

 

 

 

### 求深度与求高度的区别

 

求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）

 

 

 

求高度的算法

 

```cpp

 

 

class Solution {

 

public:

    int transation(TreeNode* root){

        if(root==nullptr) return 0;

        int left_num =transation(root->left);

        int right_num = transation(root->right);

        int result = max(left_num,right_num ) + 1;

        return result;

    }

    int maxDepth(TreeNode* root) {

     int final =   transation(root);

     return final;

 

    }

 

};

 

```

 

 

 

求深度的算法：

 

```Cpp

class Solution {

public:

    int result;

    void getDepth(TreeNode* node, int depth) {

        result = depth > result ? depth : result; // 中

 

        if (node->left == NULL && node->right == NULL) return ;

 

        if (node->left) { // 左

            depth++;    // 深度+1

            getDepth(node->left, depth);

            depth--;    // 回溯，深度-1

        }

        if (node->right) { // 右

            depth++;    // 深度+1

            getDepth(node->right, depth);

            depth--;    // 回溯，深度-1

        }

        return ;

    }

    int maxDepth(TreeNode* root) {

        result = 0;

        if (root == NULL) return result;

        getDepth(root, 1);

        return result;

    }

};

```

 

 

 

## [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

 

 

 

![image-20230308210749828](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210749828.png)

 

 

 

```cpp

 

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

class Solution {

public:

    int transation(TreeNode* root){

        if(root == nullptr) return 0;

        int left = transation(root->left);

        int right = transation(root->right);

        if(root->left == nullptr && root->right != nullptr) return 1 + right;

        if(root->right == nullptr&& root->left != nullptr) return 1 + left;

        int result =1+ min(right,left );

        return result;

    }

    int minDepth(TreeNode* root) {

        return transation(root);

    }

};

 

```

 

## [完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

 

![image-20230308210811780](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210811780.png)

 

 

 

```cpp

 

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

class Solution {

 

public:

 

    int transation(TreeNode* root){

 

        if(root == nullptr) return 0;

 

        int left = transation(root->left);

 

        int right = transation(root->right);

 

        int result = 1 + left + right;

 

        return result;

 

    }

 

    int countNodes(TreeNode* root) {

 

        return transation(root);

 

    }

 

};

 

```

 

 

 

利用完全二叉树的性质做：

 

```cpp

class Solution {

public:

    int countNodes(TreeNode* root) {

        if (root == nullptr) return 0;

        TreeNode* left = root->left;

        TreeNode* right = root->right;

        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便

        while (left) {  // 求左子树深度

            left = left->left;

            leftDepth++;

        }

        while (right) { // 求右子树深度

            right = right->right;

            rightDepth++;

        }

        if (leftDepth == rightDepth) {

            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0

        }

        return countNodes(root->left) + countNodes(root->right) + 1;

    }

};

```

 

 

 

# 第17天

 

## [平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)

 

 

 

![image-20230308210835201](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210835201.png)

 

 

 

自己的解法：挨个计算，复杂度n^2

 

```cpp

 

/**

* Definition for a binary tree node.

* struct TreeNode {

*     int val;

*     TreeNode *left;

*     TreeNode *right;

*     TreeNode() : val(0), left(nullptr), right(nullptr) {}

*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

* };

*/

 

class Solution {

 

public:

 

    int transation(TreeNode *root){

 

        if(root == nullptr) return 0;

 

        int left = transation(root->left);

 

        int right = transation(root->right);

 

        int result = 1 + max(left,right );

 

            return result;

 

    }

 

    bool isBalanced(TreeNode* root) {

 

        if(root == nullptr) return true;

 

        int left = transation(root->left);

 

        int right = transation(root->right);

 

        bool b_left=isBalanced(root->left);  //每一个节点都要求是平衡二叉树

 

        bool b_right = isBalanced(root->right);

 

        if(abs(left - right) <= 1 && (b_left && b_right)) return true;

 

        return false;

 

    }

 

};

 

```

 

 

 

优化的解法：

 

```cpp

class Solution {

public:

    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1

    int getHeight(TreeNode* node) {

        if (node == NULL) {

            return 0;

        }

        int leftHeight = getHeight(node->left);

        if (leftHeight == -1) return -1;

        int rightHeight = getHeight(node->right);

        if (rightHeight == -1) return -1;

        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);

    }

    bool isBalanced(TreeNode* root) {

        return getHeight(root) == -1 ? false : true;

    }

};

```

 

时间复杂度为logn！！！

 

 

 

## [二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/description/)

 

 

 

![image-20230308210922977](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210922977.png)

 

 

 

```cpp

// 版本一

class Solution {

private:

 

    void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {

        path.push_back(cur->val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中 

        // 这才到了叶子节点

        if (cur->left == NULL && cur->right == NULL) {

            string sPath;

            for (int i = 0; i < path.size() - 1; i++) {

                sPath += to_string(path[i]);

                sPath += "->";

            }

            sPath += to_string(path[path.size() - 1]);

            result.push_back(sPath);

            return;

        }

        if (cur->left) { // 左 

            traversal(cur->left, path, result);

            path.pop_back(); // 回溯

        }

        if (cur->right) { // 右

            traversal(cur->right, path, result);

            path.pop_back(); // 回溯

        }

    }

 

public:

    vector<string> binaryTreePaths(TreeNode* root) {

        vector<string> result;

        vector<int> path;

        if (root == NULL) return result;

        traversal(root, path, result);

        return result;

    }

};

```

 

 

 

## [左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/description/)

 

 

 

![image-20230308210948951](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308210948951.png)

 

 

 

```cpp

 

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

class Solution {

 

public:

 

    int result = 0;

 

    void transation(TreeNode*root){

 

        if(!root) return;   //可能自己遍历到空节点  比如[1,2]

 

        if(root->left == nullptr && root->right == nullptr)return ;

 

        if(root->left != nullptr && root->left->left == nullptr && root->left->right == nullptr){

 

            result+=root->left->val;

 

            //return ;

 

        }

 

        transation(root->left);

 

        transation(root->right);

 

 

 

    }

 

    int sumOfLeftLeaves(TreeNode* root) {

 

       // if(root == nullptr) return 0;

 

        transation(root);

 

        return result;

 

    }

 

};

 

```

 

 

 

优化的解题方法：

 

```cpp

class Solution {

public:

    int sumOfLeftLeaves(TreeNode* root) {

        if (root == NULL) return 0;

        if (root->left == NULL && root->right== NULL) return 0;

        int leftValue = sumOfLeftLeaves(root->left);    // 左

        if (root->left && !root->left->left && !root->left->right) { // 左子树就是一个左叶子的情况

            leftValue = root->left->val;

        }

        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = leftValue + rightValue;               // 中

        return sum;

    }

};

 

```

 

 

 

 

 

# 第18天

 

## [513\. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

 

 

 

![image-20230308211010384](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211010384.png)

 

 

 

```cpp

class Solution {

public:

    int min_depth = -1;

    int result;

    void transation(TreeNode* root,int depth){

        if(!root->left && !root->right){ //说明是一个节点

            if(depth > min_depth){

                min_depth = depth;

                result = root->val;

            }

            return;

        }

        if(root->left){

            depth++;

            transation(root->left, depth);

            depth--;

        }

        if(root->right){

            depth++;

            transation(root->right, depth);

            depth--;

        }

    }

    int findBottomLeftValue(TreeNode* root) {

        transation(root, 0);

        return result;

    }

};

 

```

 

深度和高度的概念要掌握，左下角的值就是左侧优先就好了！

 

## [112\. 路径总和](https://leetcode.cn/problems/path-sum/)

 

![image-20230308211029330](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211029330.png)

 

回溯的数组解法：

 

```cpp

class Solution {

public:

    bool result = false;

    void pathSum (TreeNode* root, int targetSum,vector<int> &path){

        if (root == nullptr)

        {

            return ;

        }      

        path.push_back(root->val);

        if (root->left == nullptr && root->right == nullptr)

        {

            //处理逻辑

            int tmp = 0;

            for (int i = 0; i < path.size(); i++)

            {

                tmp += path[i];       

            }

            if (tmp == targetSum)

            {

                result = true;

            }

        }

        if(root->left){

            pathSum(root->left,targetSum,path);

            path.pop_back();

        }        

        if(root->right){

            pathSum(root->right,targetSum,path);

            path.pop_back();

        }

    }

    bool hasPathSum(TreeNode* root, int targetSum) {

        vector<int> path;

        pathSum(root,targetSum,path);

        return result;

    }

};

```

 

 

 

```cpp

/**

* Definition for a binary tree node.

* struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

* };

*/

class Solution {

public:

   // vector<int> path;

 

    void transation(TreeNode* root, int targetSum,int &result){

       // path.push_back(root->val);

        int tmp = targetSum - root->val;

        if(!root->left && !root->right){

            //叶子节点

            if(tmp == 0){

                result = 1;

            }

            return;

        }

        if(root->left){

            int tmp1 = targetSum - root->val;

            transation(root->left, tmp1,result);

        }

        if(root->right){

            int tmp1 = targetSum - root->val;

            transation(root->right, tmp1,result);

        }

    }

    bool hasPathSum(TreeNode* root, int targetSum) {

        if(root == nullptr) {

            return false;

        }

        int result = -1;

        transation(root, targetSum,result);

        return result == -1 ? false : true;

    }

};

```

 

 

 

不需要数组的回溯算法:

 

```cpp

class Solution {

private:

    bool traversal(TreeNode* cur, int count) {

        if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0

        if (!cur->left && !cur->right) return false; // 遇到叶子节点直接返回

 

        if (cur->left) { // 左

            count -= cur->left->val; // 递归，处理节点;

            if (traversal(cur->left, count)) return true;

            count += cur->left->val; // 回溯，撤销处理结果

        }

        if (cur->right) { // 右

            count -= cur->right->val; // 递归，处理节点;

            if (traversal(cur->right, count)) return true;

            count += cur->right->val; // 回溯，撤销处理结果

        }

        return false;

    }

 

public:

    bool hasPathSum(TreeNode* root, int sum) {

        if (root == NULL) return false;

        return traversal(root, sum - root->val);

    }

};

```

 

 

 

## [106\. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

 

![image-20230308211100721](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211100721.png)

 

 

 

```cpp

class Solution {

private:

    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {

        if (postorder.size() == 0) return NULL;

 

        // 后序遍历数组最后一个元素，就是当前的中间节点

        int rootValue = postorder[postorder.size() - 1];

        TreeNode* root = new TreeNode(rootValue);

 

        // 叶子节点

        if (postorder.size() == 1) return root;

 

        // 找到中序遍历的切割点

        int delimiterIndex;

        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {

            if (inorder[delimiterIndex] == rootValue) break;

        }

 

        // 切割中序数组

        // 左闭右开区间：[0, delimiterIndex)

        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);

        // [delimiterIndex + 1, end)

        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );

 

        // postorder 舍弃末尾元素

        postorder.resize(postorder.size() - 1);//可以直接push_back()

 

        // 切割后序数组

        // 依然左闭右开，注意这里使用了左中序数组大小作为切割点

        // [0, leftInorder.size)

        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());

        // [leftInorder.size(), end)

        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

 

        root->left = traversal(leftInorder, leftPostorder);

        root->right = traversal(rightInorder, rightPostorder);

 

        return root;

    }

public:

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {

        if (inorder.size() == 0 || postorder.size() == 0) return NULL;

        return traversal(inorder, postorder);

    }

};

 

```

 

 

 

![image-20230311170130687](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230311170130687.png)

 

 

 

# 第19天

 

## [654\. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

 

 

 

![image-20230308211224427](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211224427.png)

 

 

 

```cpp

class Solution {

public:

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {

        TreeNode* node = new TreeNode(0);

        if (nums.size() == 1) {

            node->val = nums[0];

            return node;

        }

        // 找到数组中最大的值和对应的下标

        int maxValue = 0;

        int maxValueIndex = 0;

        for (int i = 0; i < nums.size(); i++) {

            if (nums[i] > maxValue) {

                maxValue = nums[i];

                maxValueIndex = i;

            }

        }

        node->val = maxValue;

        // 最大值所在的下标左区间 构造左子树

        if (maxValueIndex > 0) {

            vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);

            node->left = constructMaximumBinaryTree(newVec);

        }

        // 最大值所在的下标右区间 构造右子树

        if (maxValueIndex < (nums.size() - 1)) {

            vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());

            node->right = constructMaximumBinaryTree(newVec);

        }

        return node;

    }

};

```

 

 

 

**优化后的代码：**

 

```cpp

class Solution {

private:

    // 在左闭右开区间[left, right)，构造二叉树

    TreeNode* traversal(vector<int>& nums, int left, int right) {

        if (left >= right) return nullptr;

 

        // 分割点下标：maxValueIndex

        int maxValueIndex = left;

        for (int i = left + 1; i < right; ++i) {

            if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;

        }

 

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

 

        // 左闭右开：[left, maxValueIndex)

        root->left = traversal(nums, left, maxValueIndex);

 

        // 左闭右开：[maxValueIndex + 1, right)

        root->right = traversal(nums, maxValueIndex + 1, right);

 

        return root;

    }

public:

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {

        return traversal(nums, 0, nums.size());

    }

};

```

 

 

 

## [617\. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

 

 

 

![image-20230308211248420](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211248420.png)

 

 

 

```cpp

 

/**

 

* Definition for a binary tree node.

 

* struct TreeNode {

 

 *     int val;

 

 *     TreeNode *left;

 

 *     TreeNode *right;

 

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 

* };

 

*/

 

class Solution {

 

public:

 

    TreeNode* traversal(TreeNode* root1, TreeNode* root2){

 

        if(root1 && !root2) return root1;

 

        else if(!root1 && root2) return root2;

 

        else if(!root2 && !root1) return nullptr;

 

        int value = root2->val + root1->val;

 

        TreeNode *node = new TreeNode(value);

 

 

 

       node->left= traversal(root1->left, root2->left);

 

       node->right= traversal(root1->right, root2->right);

 

        return node;

 

 

 

    }

 

 

 

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {

 

       TreeNode *result = traversal(root1,root2);

 

       return result;

 

    }

 

};

 

```

 

## [700\. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

 

 

 

![image-20230308211309113](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211309113.png)

 

 

 

```cpp

class Solution {

public:

    TreeNode *result = nullptr;

    void traversal(TreeNode* root, int val){

        if(root == nullptr) return ;

        if(root->val == val) {

            result = root;

        }

        traversal(root->left, val);

        traversal(root->right, val);

    }

    TreeNode* searchBST(TreeNode* root, int val) {

        traversal(root, val);

        return  result;  

    }

};

 

```

 

 

 

优化的解法：

 

```Cpp

class Solution {

public:

    TreeNode* searchBST(TreeNode* root, int val) {

        if (root == NULL || root->val == val) return root;

        TreeNode* result = NULL;

        if (root->val > val) result = searchBST(root->left, val);

        if (root->val < val) result = searchBST(root->right, val);

        return result;

    }

};

```

 

 

 

## [98\. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

 

 

 

![image-20230308211342921](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211342921.png)

 

 

 

转换成数组进行处理：

 

```cpp

/**

* Definition for a binary tree node.

* struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

* };

*/

class Solution {

public:

 

    vector<int> nums;

    void traversal(TreeNode *root){

        if(root == nullptr) return ;

        traversal(root->left);

        nums.push_back(root->val);

        traversal(root->right);

    }

 

    bool isValidBST(TreeNode* root) {

        bool result = true;

        traversal(root);

        for(int i = 1; i < nums.size(); i++){

            if(nums[i] <= nums[i-1]){

                result = false;

            }

        }

        return result;

    }

};

```

 

 

 

直接在递归的过程中处理

 

```cpp

class Solution {

public:

    TreeNode* pre = NULL; // 用来记录前一个节点

    bool isValidBST(TreeNode* root) {

        if (root == NULL) return true;

        bool left = isValidBST(root->left);

 

        if (pre != NULL && pre->val >= root->val) return false;

        pre = root; // 记录前一个节点

 

        bool right = isValidBST(root->right);

        return left && right;

    }

};

```

 

 

 

# 第20天

 

## [二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/)

 

![image-20230308211410348](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211410348.png)

 

 

 

```cpp

/**

* Definition for a binary tree node.

* struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

* };

*/

#include<iostream>

#include<vector>

#include <algorithm>

using namespace std;

 

 

class Solution {

public:

vector<int> nums;

    void  transation(TreeNode* root){

        if (!root)

        {

            return;

        }

        transation(root->left);

        nums.push_back(root->val);

        transation(root->right);

    }

 

    int getMinimumDifference(TreeNode* root) {

        transation(root);

        int result = nums[1]-nums[0];

        for (int i = 2; i < nums.size(); i++)

        {

            result = min(result,nums[i] - nums[i-1]);

        }

        return result;

    }

};

```

 

 

 

 

 

 

 

## [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

 

![image-20230308211435475](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211435475.png)

 

 

 

```cpp

/**

* Definition for a binary tree node.

* struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

* };

*/

class Solution {

public:

    vector<int> nums;

    void  transation(TreeNode* root){

        if (!root)

        {

            return;

        }

        transation(root->left);

        nums.push_back(root->val);

        transation(root->right);

    }

 

    vector<int> findMode(TreeNode* root) {

        transation(root);

        unordered_map<int,int> map;

        for (int i = 0; i < nums.size(); i++)

        {

            map[nums[i]]++;

        }

 

        vector<int> result;

        int max = -1;

        for (auto it = map.begin(); it != map.end(); ++it)

        {

            if (it->second > max)

            {

                max = it->second;

            }

        }

 

        for (auto it = map.begin(); it != map.end(); ++it)

        {

            if (it->second == max)

            {

                result.push_back(it->first);

            }

        }

        return result;

    }

};

```

 

 

 

### 一遍搜索实现的函数

 

```cpp

class Solution {

private:

    int maxCount = 0; // 最大频率

    int count = 0; // 统计频率

    TreeNode* pre = NULL;

    vector<int> result;

    void searchBST(TreeNode* cur) {

        if (cur == NULL) return ;

 

        searchBST(cur->left);       // 左

                                    // 中

        if (pre == NULL) { // 第一个节点

            count = 1;

        } else if (pre->val == cur->val) { // 与前一个节点数值相同

            count++;

        } else { // 与前一个节点数值不同

            count = 1;

        }

        pre = cur; // 更新上一个节点

 

        if (count == maxCount) { // 如果和最大值相同，放进result中

            result.push_back(cur->val);

        }

 

        if (count > maxCount) { // 如果计数大于最大值频率

            maxCount = count;   // 更新最大频率

            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了

            result.push_back(cur->val);

        }

 

        searchBST(cur->right);      // 右

        return ;

    }

 

public:

    vector<int> findMode(TreeNode* root) {

        count = 0;

        maxCount = 0;

        TreeNode* pre = NULL; // 记录前一个节点

        result.clear();

 

        searchBST(root);

        return result;

    }

};

```

 

 

 

 

 

## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

 

 

 

![image-20230308211549951](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230308211549951.png)

 

 

 

```cpp

/**

* Definition for a binary tree node.

* struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}

* };

*/

#include<iostream>

#include <vector>

using namespace std;

 

 

class Solution {

public:

    TreeNode* traversal(TreeNode* root, TreeNode* p, TreeNode* q){

        if (root == nullptr || root == q || root ==p )

        {

            return root;

        }

        TreeNode *left = traversal(root->left,p,q);

        TreeNode *right = traversal(root->right,p,q);

 

        if (left && !right)

        {

            return left;

        }else if (!left && right)

        {

            return right;

        }else if (left && right)

        {

            return root;

        }else{

            return nullptr;

        }

    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

       TreeNode* result =  traversal(root,p,q);

       return result;

    }

};

```

 

 

 

## 搜索的区别（单边还是整个树）

 

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。

 

![image-20230311195704447](https://ayu-990121-1302263000.cos.ap-nanjing.myqcloud.com/makedown/image-20230311195704447.png) 




